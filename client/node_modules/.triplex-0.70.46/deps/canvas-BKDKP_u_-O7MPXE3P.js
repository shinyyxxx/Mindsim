import {
  l,
  n,
  o,
  r,
  s,
  t
} from "./chunk-MKJCJPV3.js";
import {
  d
} from "./chunk-DDGPQRI7.js";
import {
  ArrayCamera,
  BackSide,
  Box3,
  BoxGeometry,
  BufferGeometry,
  Camera,
  Canvas,
  CanvasTexture,
  Color,
  CylinderGeometry,
  DepthTexture,
  DoubleSide,
  Euler,
  Float32BufferAttribute,
  FloatType,
  Group,
  HalfFloatType,
  Line,
  Line3,
  LineBasicMaterial,
  LineSegments,
  LinearFilter,
  MathUtils,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  Quaternion,
  REVISION,
  Ray,
  Raycaster,
  Scene,
  ShaderMaterial,
  Sphere,
  SphereGeometry,
  Spherical,
  TorusGeometry,
  Triangle,
  Uniform,
  UniformsUtils,
  Vector2,
  Vector3,
  Vector4,
  WebGLRenderTarget,
  applyProps,
  createPortal,
  extend,
  useFrame,
  useStore,
  useThree
} from "./chunk-KSHOG73P.js";
import {
  $o,
  Do,
  Es,
  F,
  Go,
  Gt,
  Hr,
  N,
  Oe,
  Os,
  Pe,
  Ro,
  V,
  Xr,
  Yr,
  ai,
  dt,
  ei,
  eo,
  ho,
  ii,
  ko,
  ni,
  on,
  po,
  rn,
  ss,
  ur,
  vo
} from "./chunk-2O755BNZ.js";
import "./chunk-F5X6INBZ.js";
import {
  require_jsx_runtime
} from "./chunk-FXVZLN7E.js";
import {
  require_react
} from "./chunk-KMU3Z7QX.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// ../../../Users/Admin/.vscode/extensions/trytriplex.triplex-vsce-0.2.55/node_modules/@triplex/renderer/dist/canvas-BKDKP_u_.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var I = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var Vr = Object.defineProperty;
var Qr = (n2, t2, e) => t2 in n2 ? Vr(n2, t2, { enumerable: true, configurable: true, writable: true, value: e }) : n2[t2] = e;
var f = (n2, t2, e) => Qr(n2, typeof t2 != "symbol" ? t2 + "" : t2, e);
function Ze(n2, t2) {
  let e;
  return t2.ctrl ? typeof n2 == "number" ? e = n2 * 25 : e = n2.ctrl : e = typeof n2 == "number" ? n2 : n2.default, t2.shift && (e /= 10), e;
}
function vr({
  isDisabled: n2
} = {}) {
  const [t2, e] = (0, import_react.useState)({
    ctrl: false,
    shift: false
  });
  return (0, import_react.useLayoutEffect)(() => {
    if (!n2)
      return () => {
        e({ ctrl: false, shift: false });
      };
  }, [n2]), (0, import_react.useEffect)(() => {
    if (n2)
      return;
    const i = (r2) => {
      r2.ctrlKey && e((o2) => ({ ...o2, ctrl: true })), r2.shiftKey && e((o2) => ({ ...o2, shift: true }));
    }, s2 = (r2) => {
      e({ ctrl: r2.ctrlKey, shift: r2.shiftKey });
    };
    return window.addEventListener("keydown", i), window.addEventListener("keyup", s2), () => {
      window.removeEventListener("keydown", i), window.removeEventListener("keyup", s2);
    };
  }, [n2]), t2;
}
function ye() {
  return ye = Object.assign ? Object.assign.bind() : function(n2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var e = arguments[t2];
      for (var i in e) ({}).hasOwnProperty.call(e, i) && (n2[i] = e[i]);
    }
    return n2;
  }, ye.apply(null, arguments);
}
var bo = Object.defineProperty;
var Eo = (n2, t2, e) => t2 in n2 ? bo(n2, t2, { enumerable: true, configurable: true, writable: true, value: e }) : n2[t2] = e;
var w = (n2, t2, e) => (Eo(n2, typeof t2 != "symbol" ? t2 + "" : t2, e), e);
var To = class extends Object3D {
  constructor(t2, e) {
    super(), w(this, "isTransformControls", true), w(this, "visible", false), w(this, "domElement"), w(this, "raycaster", new Raycaster()), w(this, "gizmo"), w(this, "plane"), w(this, "tempVector", new Vector3()), w(this, "tempVector2", new Vector3()), w(this, "tempQuaternion", new Quaternion()), w(this, "unit", {
      X: new Vector3(1, 0, 0),
      Y: new Vector3(0, 1, 0),
      Z: new Vector3(0, 0, 1)
    }), w(this, "pointStart", new Vector3()), w(this, "pointEnd", new Vector3()), w(this, "offset", new Vector3()), w(this, "rotationAxis", new Vector3()), w(this, "startNorm", new Vector3()), w(this, "endNorm", new Vector3()), w(this, "rotationAngle", 0), w(this, "cameraPosition", new Vector3()), w(this, "cameraQuaternion", new Quaternion()), w(this, "cameraScale", new Vector3()), w(this, "parentPosition", new Vector3()), w(this, "parentQuaternion", new Quaternion()), w(this, "parentQuaternionInv", new Quaternion()), w(this, "parentScale", new Vector3()), w(this, "worldPositionStart", new Vector3()), w(this, "worldQuaternionStart", new Quaternion()), w(this, "worldScaleStart", new Vector3()), w(this, "worldPosition", new Vector3()), w(this, "worldQuaternion", new Quaternion()), w(this, "worldQuaternionInv", new Quaternion()), w(this, "worldScale", new Vector3()), w(this, "eye", new Vector3()), w(this, "positionStart", new Vector3()), w(this, "quaternionStart", new Quaternion()), w(this, "scaleStart", new Vector3()), w(this, "camera"), w(this, "object"), w(this, "enabled", true), w(this, "axis", null), w(this, "mode", "translate"), w(this, "translationSnap", null), w(this, "rotationSnap", null), w(this, "scaleSnap", null), w(this, "space", "world"), w(this, "size", 1), w(this, "dragging", false), w(this, "showX", true), w(this, "showY", true), w(this, "showZ", true), w(this, "changeEvent", { type: "change" }), w(this, "mouseDownEvent", { type: "mouseDown", mode: this.mode }), w(this, "mouseUpEvent", { type: "mouseUp", mode: this.mode }), w(this, "objectChangeEvent", { type: "objectChange" }), w(this, "intersectObjectWithRay", (s2, r2, o2) => {
      const a = r2.intersectObject(s2, true);
      for (let l2 = 0; l2 < a.length; l2++)
        if (a[l2].object.visible || o2)
          return a[l2];
      return false;
    }), w(this, "attach", (s2) => (this.object = s2, this.visible = true, this)), w(this, "detach", () => (this.object = void 0, this.visible = false, this.axis = null, this)), w(this, "reset", () => this.enabled ? (this.dragging && this.object !== void 0 && (this.object.position.copy(this.positionStart), this.object.quaternion.copy(this.quaternionStart), this.object.scale.copy(this.scaleStart), this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent), this.pointStart.copy(this.pointEnd)), this) : this), w(this, "updateMatrixWorld", () => {
      this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this.parentPosition, this.parentQuaternion, this.parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this.worldScale), this.parentQuaternionInv.copy(this.parentQuaternion).invert(), this.worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this.cameraScale), this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld();
    }), w(this, "pointerHover", (s2) => {
      if (this.object === void 0 || this.dragging === true)
        return;
      this.raycaster.setFromCamera(s2, this.camera);
      const r2 = this.intersectObjectWithRay(this.gizmo.picker[this.mode], this.raycaster);
      r2 ? this.axis = r2.object.name : this.axis = null;
    }), w(this, "pointerDown", (s2) => {
      if (!(this.object === void 0 || this.dragging === true || s2.button !== 0) && this.axis !== null) {
        this.raycaster.setFromCamera(s2, this.camera);
        const r2 = this.intersectObjectWithRay(this.plane, this.raycaster, true);
        if (r2) {
          let o2 = this.space;
          if (this.mode === "scale" ? o2 = "local" : (this.axis === "E" || this.axis === "XYZE" || this.axis === "XYZ") && (o2 = "world"), o2 === "local" && this.mode === "rotate") {
            const a = this.rotationSnap;
            this.axis === "X" && a && (this.object.rotation.x = Math.round(this.object.rotation.x / a) * a), this.axis === "Y" && a && (this.object.rotation.y = Math.round(this.object.rotation.y / a) * a), this.axis === "Z" && a && (this.object.rotation.z = Math.round(this.object.rotation.z / a) * a);
          }
          this.object.updateMatrixWorld(), this.object.parent && this.object.parent.updateMatrixWorld(), this.positionStart.copy(this.object.position), this.quaternionStart.copy(this.object.quaternion), this.scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this.worldScaleStart), this.pointStart.copy(r2.point).sub(this.worldPositionStart);
        }
        this.dragging = true, this.mouseDownEvent.mode = this.mode, this.dispatchEvent(this.mouseDownEvent);
      }
    }), w(this, "pointerMove", (s2) => {
      const r2 = this.axis, o2 = this.mode, a = this.object;
      let l2 = this.space;
      if (o2 === "scale" ? l2 = "local" : (r2 === "E" || r2 === "XYZE" || r2 === "XYZ") && (l2 = "world"), a === void 0 || r2 === null || this.dragging === false || s2.button !== -1)
        return;
      this.raycaster.setFromCamera(s2, this.camera);
      const c = this.intersectObjectWithRay(this.plane, this.raycaster, true);
      if (c) {
        if (this.pointEnd.copy(c.point).sub(this.worldPositionStart), o2 === "translate")
          this.offset.copy(this.pointEnd).sub(this.pointStart), l2 === "local" && r2 !== "XYZ" && this.offset.applyQuaternion(this.worldQuaternionInv), r2.indexOf("X") === -1 && (this.offset.x = 0), r2.indexOf("Y") === -1 && (this.offset.y = 0), r2.indexOf("Z") === -1 && (this.offset.z = 0), l2 === "local" && r2 !== "XYZ" ? this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale) : this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale), a.position.copy(this.offset).add(this.positionStart), this.translationSnap && (l2 === "local" && (a.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()), r2.search("X") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), r2.search("Y") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), r2.search("Z") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.position.applyQuaternion(this.quaternionStart)), l2 === "world" && (a.parent && a.position.add(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld)), r2.search("X") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), r2.search("Y") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), r2.search("Z") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.parent && a.position.sub(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld))));
        else if (o2 === "scale") {
          if (r2.search("XYZ") !== -1) {
            let h = this.pointEnd.length() / this.pointStart.length();
            this.pointEnd.dot(this.pointStart) < 0 && (h *= -1), this.tempVector2.set(h, h, h);
          } else
            this.tempVector.copy(this.pointStart), this.tempVector2.copy(this.pointEnd), this.tempVector.applyQuaternion(this.worldQuaternionInv), this.tempVector2.applyQuaternion(this.worldQuaternionInv), this.tempVector2.divide(this.tempVector), r2.search("X") === -1 && (this.tempVector2.x = 1), r2.search("Y") === -1 && (this.tempVector2.y = 1), r2.search("Z") === -1 && (this.tempVector2.z = 1);
          a.scale.copy(this.scaleStart).multiply(this.tempVector2), this.scaleSnap && this.object && (r2.search("X") !== -1 && (this.object.scale.x = Math.round(a.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), r2.search("Y") !== -1 && (a.scale.y = Math.round(a.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), r2.search("Z") !== -1 && (a.scale.z = Math.round(a.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
        } else if (o2 === "rotate") {
          this.offset.copy(this.pointEnd).sub(this.pointStart);
          const h = 20 / this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));
          r2 === "E" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this.startNorm.copy(this.pointStart).normalize(), this.endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this.endNorm.cross(this.startNorm).dot(this.eye) < 0 ? 1 : -1) : r2 === "XYZE" ? (this.rotationAxis.copy(this.offset).cross(this.eye).normalize(), this.rotationAngle = this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye)) * h) : (r2 === "X" || r2 === "Y" || r2 === "Z") && (this.rotationAxis.copy(this.unit[r2]), this.tempVector.copy(this.unit[r2]), l2 === "local" && this.tempVector.applyQuaternion(this.worldQuaternion), this.rotationAngle = this.offset.dot(this.tempVector.cross(this.eye).normalize()) * h), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), l2 === "local" && r2 !== "E" && r2 !== "XYZE" ? (a.quaternion.copy(this.quaternionStart), a.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this.parentQuaternionInv), a.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), a.quaternion.multiply(this.quaternionStart).normalize());
        }
        this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent);
      }
    }), w(this, "pointerUp", (s2) => {
      s2.button === 0 && (this.dragging && this.axis !== null && (this.mouseUpEvent.mode = this.mode, this.dispatchEvent(this.mouseUpEvent)), this.dragging = false, this.axis = null);
    }), w(this, "getPointer", (s2) => {
      var r2;
      if (this.domElement && ((r2 = this.domElement.ownerDocument) != null && r2.pointerLockElement))
        return {
          x: 0,
          y: 0,
          button: s2.button
        };
      {
        const o2 = s2.changedTouches ? s2.changedTouches[0] : s2, a = this.domElement.getBoundingClientRect();
        return {
          x: (o2.clientX - a.left) / a.width * 2 - 1,
          y: -(o2.clientY - a.top) / a.height * 2 + 1,
          button: s2.button
        };
      }
    }), w(this, "onPointerHover", (s2) => {
      if (this.enabled)
        switch (s2.pointerType) {
          case "mouse":
          case "pen":
            this.pointerHover(this.getPointer(s2));
            break;
        }
    }), w(this, "onPointerDown", (s2) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "none", this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove), this.pointerHover(this.getPointer(s2)), this.pointerDown(this.getPointer(s2)));
    }), w(this, "onPointerMove", (s2) => {
      this.enabled && this.pointerMove(this.getPointer(s2));
    }), w(this, "onPointerUp", (s2) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "", this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove), this.pointerUp(this.getPointer(s2)));
    }), w(this, "getMode", () => this.mode), w(this, "setMode", (s2) => {
      this.mode = s2;
    }), w(this, "setTranslationSnap", (s2) => {
      this.translationSnap = s2;
    }), w(this, "setRotationSnap", (s2) => {
      this.rotationSnap = s2;
    }), w(this, "setScaleSnap", (s2) => {
      this.scaleSnap = s2;
    }), w(this, "setSize", (s2) => {
      this.size = s2;
    }), w(this, "setSpace", (s2) => {
      this.space = s2;
    }), w(this, "update", () => {
      console.warn(
        "THREE.TransformControls: update function has no more functionality and therefore has been deprecated."
      );
    }), w(this, "connect", (s2) => {
      s2 === document && console.error(
        'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
      ), this.domElement = s2, this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("pointermove", this.onPointerHover), this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp);
    }), w(this, "dispose", () => {
      var s2, r2, o2, a, l2, c;
      (s2 = this.domElement) == null || s2.removeEventListener("pointerdown", this.onPointerDown), (r2 = this.domElement) == null || r2.removeEventListener("pointermove", this.onPointerHover), (a = (o2 = this.domElement) == null ? void 0 : o2.ownerDocument) == null || a.removeEventListener("pointermove", this.onPointerMove), (c = (l2 = this.domElement) == null ? void 0 : l2.ownerDocument) == null || c.removeEventListener("pointerup", this.onPointerUp), this.traverse((h) => {
        const u = h;
        u.geometry && u.geometry.dispose(), u.material && u.material.dispose();
      });
    }), this.domElement = e, this.camera = t2, this.gizmo = new Oo(), this.add(this.gizmo), this.plane = new Po(), this.add(this.plane);
    const i = (s2, r2) => {
      let o2 = r2;
      Object.defineProperty(this, s2, {
        get: function() {
          return o2 !== void 0 ? o2 : r2;
        },
        set: function(a) {
          o2 !== a && (o2 = a, this.plane[s2] = a, this.gizmo[s2] = a, this.dispatchEvent({ type: s2 + "-changed", value: a }), this.dispatchEvent(this.changeEvent));
        }
      }), this[s2] = r2, this.plane[s2] = r2, this.gizmo[s2] = r2;
    };
    i("camera", this.camera), i("object", this.object), i("enabled", this.enabled), i("axis", this.axis), i("mode", this.mode), i("translationSnap", this.translationSnap), i("rotationSnap", this.rotationSnap), i("scaleSnap", this.scaleSnap), i("space", this.space), i("size", this.size), i("dragging", this.dragging), i("showX", this.showX), i("showY", this.showY), i("showZ", this.showZ), i("worldPosition", this.worldPosition), i("worldPositionStart", this.worldPositionStart), i("worldQuaternion", this.worldQuaternion), i("worldQuaternionStart", this.worldQuaternionStart), i("cameraPosition", this.cameraPosition), i("cameraQuaternion", this.cameraQuaternion), i("pointStart", this.pointStart), i("pointEnd", this.pointEnd), i("rotationAxis", this.rotationAxis), i("rotationAngle", this.rotationAngle), i("eye", this.eye), e !== void 0 && this.connect(e);
  }
};
var Oo = class extends Object3D {
  constructor() {
    super(), w(this, "isTransformControlsGizmo", true), w(this, "type", "TransformControlsGizmo"), w(this, "tempVector", new Vector3(0, 0, 0)), w(this, "tempEuler", new Euler()), w(this, "alignVector", new Vector3(0, 1, 0)), w(this, "zeroVector", new Vector3(0, 0, 0)), w(this, "lookAtMatrix", new Matrix4()), w(this, "tempQuaternion", new Quaternion()), w(this, "tempQuaternion2", new Quaternion()), w(this, "identityQuaternion", new Quaternion()), w(this, "unitX", new Vector3(1, 0, 0)), w(this, "unitY", new Vector3(0, 1, 0)), w(this, "unitZ", new Vector3(0, 0, 1)), w(this, "gizmo"), w(this, "picker"), w(this, "helper"), w(this, "rotationAxis", new Vector3()), w(this, "cameraPosition", new Vector3()), w(this, "worldPositionStart", new Vector3()), w(this, "worldQuaternionStart", new Quaternion()), w(this, "worldPosition", new Vector3()), w(this, "worldQuaternion", new Quaternion()), w(this, "eye", new Vector3()), w(this, "camera", null), w(this, "enabled", true), w(this, "axis", null), w(this, "mode", "translate"), w(this, "space", "world"), w(this, "size", 1), w(this, "dragging", false), w(this, "showX", true), w(this, "showY", true), w(this, "showZ", true), w(this, "updateMatrixWorld", () => {
      let $ = this.space;
      this.mode === "scale" && ($ = "local");
      const z = $ === "local" ? this.worldQuaternion : this.identityQuaternion;
      this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
      let U = [];
      U = U.concat(this.picker[this.mode].children), U = U.concat(this.gizmo[this.mode].children), U = U.concat(this.helper[this.mode].children);
      for (let dt2 = 0; dt2 < U.length; dt2++) {
        const _ = U[dt2];
        _.visible = true, _.rotation.set(0, 0, 0), _.position.copy(this.worldPosition);
        let ft;
        if (this.camera.isOrthographicCamera ? ft = (this.camera.top - this.camera.bottom) / this.camera.zoom : ft = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), _.scale.set(1, 1, 1).multiplyScalar(ft * this.size / 7), _.tag === "helper") {
          _.visible = false, _.name === "AXIS" ? (_.position.copy(this.worldPositionStart), _.visible = !!this.axis, this.axis === "X" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, 0)), _.quaternion.copy(z).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(z).dot(this.eye)) > 0.9 && (_.visible = false)), this.axis === "Y" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, Math.PI / 2)), _.quaternion.copy(z).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(z).dot(this.eye)) > 0.9 && (_.visible = false)), this.axis === "Z" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), _.quaternion.copy(z).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(z).dot(this.eye)) > 0.9 && (_.visible = false)), this.axis === "XYZE" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), this.alignVector.copy(this.rotationAxis), _.quaternion.setFromRotationMatrix(
            this.lookAtMatrix.lookAt(this.zeroVector, this.alignVector, this.unitY)
          ), _.quaternion.multiply(this.tempQuaternion), _.visible = this.dragging), this.axis === "E" && (_.visible = false)) : _.name === "START" ? (_.position.copy(this.worldPositionStart), _.visible = this.dragging) : _.name === "END" ? (_.position.copy(this.worldPosition), _.visible = this.dragging) : _.name === "DELTA" ? (_.position.copy(this.worldPositionStart), _.quaternion.copy(this.worldQuaternionStart), this.tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()), _.scale.copy(this.tempVector), _.visible = this.dragging) : (_.quaternion.copy(z), this.dragging ? _.position.copy(this.worldPositionStart) : _.position.copy(this.worldPosition), this.axis && (_.visible = this.axis.search(_.name) !== -1));
          continue;
        }
        _.quaternion.copy(z), this.mode === "translate" || this.mode === "scale" ? ((_.name === "X" || _.name === "XYZX") && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(z).dot(this.eye)) > 0.99 && (_.scale.set(1e-10, 1e-10, 1e-10), _.visible = false), (_.name === "Y" || _.name === "XYZY") && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(z).dot(this.eye)) > 0.99 && (_.scale.set(1e-10, 1e-10, 1e-10), _.visible = false), (_.name === "Z" || _.name === "XYZZ") && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(z).dot(this.eye)) > 0.99 && (_.scale.set(1e-10, 1e-10, 1e-10), _.visible = false), _.name === "XY" && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(z).dot(this.eye)) < 0.2 && (_.scale.set(1e-10, 1e-10, 1e-10), _.visible = false), _.name === "YZ" && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(z).dot(this.eye)) < 0.2 && (_.scale.set(1e-10, 1e-10, 1e-10), _.visible = false), _.name === "XZ" && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(z).dot(this.eye)) < 0.2 && (_.scale.set(1e-10, 1e-10, 1e-10), _.visible = false), _.name.search("X") !== -1 && (this.alignVector.copy(this.unitX).applyQuaternion(z).dot(this.eye) < 0 ? _.tag === "fwd" ? _.visible = false : _.scale.x *= -1 : _.tag === "bwd" && (_.visible = false)), _.name.search("Y") !== -1 && (this.alignVector.copy(this.unitY).applyQuaternion(z).dot(this.eye) < 0 ? _.tag === "fwd" ? _.visible = false : _.scale.y *= -1 : _.tag === "bwd" && (_.visible = false)), _.name.search("Z") !== -1 && (this.alignVector.copy(this.unitZ).applyQuaternion(z).dot(this.eye) < 0 ? _.tag === "fwd" ? _.visible = false : _.scale.z *= -1 : _.tag === "bwd" && (_.visible = false))) : this.mode === "rotate" && (this.tempQuaternion2.copy(z), this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(z).invert()), _.name.search("E") !== -1 && _.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye, this.zeroVector, this.unitY)), _.name === "X" && (this.tempQuaternion.setFromAxisAngle(this.unitX, Math.atan2(-this.alignVector.y, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), _.quaternion.copy(this.tempQuaternion)), _.name === "Y" && (this.tempQuaternion.setFromAxisAngle(this.unitY, Math.atan2(this.alignVector.x, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), _.quaternion.copy(this.tempQuaternion)), _.name === "Z" && (this.tempQuaternion.setFromAxisAngle(this.unitZ, Math.atan2(this.alignVector.y, this.alignVector.x)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), _.quaternion.copy(this.tempQuaternion))), _.visible = _.visible && (_.name.indexOf("X") === -1 || this.showX), _.visible = _.visible && (_.name.indexOf("Y") === -1 || this.showY), _.visible = _.visible && (_.name.indexOf("Z") === -1 || this.showZ), _.visible = _.visible && (_.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), _.material.tempOpacity = _.material.tempOpacity || _.material.opacity, _.material.tempColor = _.material.tempColor || _.material.color.clone(), _.material.color.copy(_.material.tempColor), _.material.opacity = _.material.tempOpacity, this.enabled ? this.axis && (_.name === this.axis ? (_.material.opacity = 1, _.material.color.lerp(new Color(1, 1, 1), 0.5)) : this.axis.split("").some(function(ae) {
          return _.name === ae;
        }) ? (_.material.opacity = 1, _.material.color.lerp(new Color(1, 1, 1), 0.5)) : (_.material.opacity *= 0.25, _.material.color.lerp(new Color(1, 1, 1), 0.5))) : (_.material.opacity *= 0.5, _.material.color.lerp(new Color(1, 1, 1), 0.5));
      }
      super.updateMatrixWorld();
    });
    const t2 = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      transparent: true,
      side: DoubleSide,
      fog: false,
      toneMapped: false
    }), e = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      transparent: true,
      linewidth: 1,
      fog: false,
      toneMapped: false
    }), i = t2.clone();
    i.opacity = 0.15;
    const s2 = t2.clone();
    s2.opacity = 0.33;
    const r2 = t2.clone();
    r2.color.set(16711680);
    const o2 = t2.clone();
    o2.color.set(65280);
    const a = t2.clone();
    a.color.set(255);
    const l2 = t2.clone();
    l2.opacity = 0.25;
    const c = l2.clone();
    c.color.set(16776960);
    const h = l2.clone();
    h.color.set(65535);
    const u = l2.clone();
    u.color.set(16711935), t2.clone().color.set(16776960);
    const y = e.clone();
    y.color.set(16711680);
    const T = e.clone();
    T.color.set(65280);
    const b = e.clone();
    b.color.set(255);
    const d2 = e.clone();
    d2.color.set(65535);
    const v = e.clone();
    v.color.set(16711935);
    const E = e.clone();
    E.color.set(16776960);
    const S = e.clone();
    S.color.set(7895160);
    const M = E.clone();
    M.opacity = 0.25;
    const x = new CylinderGeometry(0, 0.05, 0.2, 12, 1, false), O = new BoxGeometry(0.125, 0.125, 0.125), A = new BufferGeometry();
    A.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const Q = ($, z) => {
      const U = new BufferGeometry(), dt2 = [];
      for (let _ = 0; _ <= 64 * z; ++_)
        dt2.push(0, Math.cos(_ / 32 * Math.PI) * $, Math.sin(_ / 32 * Math.PI) * $);
      return U.setAttribute("position", new Float32BufferAttribute(dt2, 3)), U;
    }, ht = () => {
      const $ = new BufferGeometry();
      return $.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3)), $;
    }, _t = {
      X: [
        [new Mesh(x, r2), [1, 0, 0], [0, 0, -Math.PI / 2], null, "fwd"],
        [new Mesh(x, r2), [1, 0, 0], [0, 0, Math.PI / 2], null, "bwd"],
        [new Line(A, y)]
      ],
      Y: [
        [new Mesh(x, o2), [0, 1, 0], null, null, "fwd"],
        [new Mesh(x, o2), [0, 1, 0], [Math.PI, 0, 0], null, "bwd"],
        [new Line(A, T), null, [0, 0, Math.PI / 2]]
      ],
      Z: [
        [new Mesh(x, a), [0, 0, 1], [Math.PI / 2, 0, 0], null, "fwd"],
        [new Mesh(x, a), [0, 0, 1], [-Math.PI / 2, 0, 0], null, "bwd"],
        [new Line(A, b), null, [0, -Math.PI / 2, 0]]
      ],
      XYZ: [[new Mesh(new OctahedronGeometry(0.1, 0), l2.clone()), [0, 0, 0], [0, 0, 0]]],
      XY: [
        [new Mesh(new PlaneGeometry(0.295, 0.295), c.clone()), [0.15, 0.15, 0]],
        [new Line(A, E), [0.18, 0.3, 0], null, [0.125, 1, 1]],
        [new Line(A, E), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new Mesh(new PlaneGeometry(0.295, 0.295), h.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]],
        [new Line(A, d2), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new Line(A, d2), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [
          new Mesh(new PlaneGeometry(0.295, 0.295), u.clone()),
          [0.15, 0, 0.15],
          [-Math.PI / 2, 0, 0]
        ],
        [new Line(A, v), [0.18, 0, 0.3], null, [0.125, 1, 1]],
        [new Line(A, v), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ]
    }, kt = {
      X: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), i), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), i), [0, 0.6, 0]]],
      Z: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), i), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
      XYZ: [[new Mesh(new OctahedronGeometry(0.2, 0), i)]],
      XY: [[new Mesh(new PlaneGeometry(0.4, 0.4), i), [0.2, 0.2, 0]]],
      YZ: [[new Mesh(new PlaneGeometry(0.4, 0.4), i), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],
      XZ: [[new Mesh(new PlaneGeometry(0.4, 0.4), i), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]
    }, k = {
      START: [[new Mesh(new OctahedronGeometry(0.01, 2), s2), null, null, null, "helper"]],
      END: [[new Mesh(new OctahedronGeometry(0.01, 2), s2), null, null, null, "helper"]],
      DELTA: [[new Line(ht(), s2), null, null, null, "helper"]],
      X: [[new Line(A, s2.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new Line(A, s2.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new Line(A, s2.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, D = {
      X: [
        [new Line(Q(1, 0.5), y)],
        [new Mesh(new OctahedronGeometry(0.04, 0), r2), [0, 0, 0.99], null, [1, 3, 1]]
      ],
      Y: [
        [new Line(Q(1, 0.5), T), null, [0, 0, -Math.PI / 2]],
        [new Mesh(new OctahedronGeometry(0.04, 0), o2), [0, 0, 0.99], null, [3, 1, 1]]
      ],
      Z: [
        [new Line(Q(1, 0.5), b), null, [0, Math.PI / 2, 0]],
        [new Mesh(new OctahedronGeometry(0.04, 0), a), [0.99, 0, 0], null, [1, 3, 1]]
      ],
      E: [
        [new Line(Q(1.25, 1), M), null, [0, Math.PI / 2, 0]],
        [
          new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), M),
          [1.17, 0, 0],
          [0, 0, -Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), M),
          [-1.17, 0, 0],
          [0, 0, Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), M),
          [0, -1.17, 0],
          [Math.PI, 0, 0],
          [1, 1, 1e-3]
        ],
        [
          new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), M),
          [0, 1.17, 0],
          [0, 0, 0],
          [1, 1, 1e-3]
        ]
      ],
      XYZE: [[new Line(Q(1, 1), S), null, [0, Math.PI / 2, 0]]]
    }, At = {
      AXIS: [[new Line(A, s2.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
    }, j = {
      X: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), i), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
      Y: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), i), [0, 0, 0], [Math.PI / 2, 0, 0]]],
      Z: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), i), [0, 0, 0], [0, 0, -Math.PI / 2]]],
      E: [[new Mesh(new TorusGeometry(1.25, 0.1, 2, 24), i)]],
      XYZE: [[new Mesh(new SphereGeometry(0.7, 10, 8), i)]]
    }, Gt2 = {
      X: [
        [new Mesh(O, r2), [0.8, 0, 0], [0, 0, -Math.PI / 2]],
        [new Line(A, y), null, null, [0.8, 1, 1]]
      ],
      Y: [
        [new Mesh(O, o2), [0, 0.8, 0]],
        [new Line(A, T), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]
      ],
      Z: [
        [new Mesh(O, a), [0, 0, 0.8], [Math.PI / 2, 0, 0]],
        [new Line(A, b), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]
      ],
      XY: [
        [new Mesh(O, c), [0.85, 0.85, 0], null, [2, 2, 0.2]],
        [new Line(A, E), [0.855, 0.98, 0], null, [0.125, 1, 1]],
        [new Line(A, E), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new Mesh(O, h), [0, 0.85, 0.85], null, [0.2, 2, 2]],
        [new Line(A, d2), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new Line(A, d2), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [new Mesh(O, u), [0.85, 0, 0.85], null, [2, 0.2, 2]],
        [new Line(A, v), [0.855, 0, 0.98], null, [0.125, 1, 1]],
        [new Line(A, v), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XYZX: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), l2.clone()), [1.1, 0, 0]]],
      XYZY: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), l2.clone()), [0, 1.1, 0]]],
      XYZZ: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), l2.clone()), [0, 0, 1.1]]]
    }, Kt = {
      X: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), i), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), i), [0, 0.5, 0]]],
      Z: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), i), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],
      XY: [[new Mesh(O, i), [0.85, 0.85, 0], null, [3, 3, 0.2]]],
      YZ: [[new Mesh(O, i), [0, 0.85, 0.85], null, [0.2, 3, 3]]],
      XZ: [[new Mesh(O, i), [0.85, 0, 0.85], null, [3, 0.2, 3]]],
      XYZX: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), i), [1.1, 0, 0]]],
      XYZY: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), i), [0, 1.1, 0]]],
      XYZZ: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), i), [0, 0, 1.1]]]
    }, Jt = {
      X: [[new Line(A, s2.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new Line(A, s2.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new Line(A, s2.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, ut = ($) => {
      const z = new Object3D();
      for (let U in $)
        for (let dt2 = $[U].length; dt2--; ) {
          const _ = $[U][dt2][0].clone(), ft = $[U][dt2][1], ae = $[U][dt2][2], $e = $[U][dt2][3], is = $[U][dt2][4];
          _.name = U, _.tag = is, ft && _.position.set(ft[0], ft[1], ft[2]), ae && _.rotation.set(ae[0], ae[1], ae[2]), $e && _.scale.set($e[0], $e[1], $e[2]), _.updateMatrix();
          const ns = _.geometry.clone();
          ns.applyMatrix4(_.matrix), _.geometry = ns, _.renderOrder = 1 / 0, _.position.set(0, 0, 0), _.rotation.set(0, 0, 0), _.scale.set(1, 1, 1), z.add(_);
        }
      return z;
    };
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = ut(_t)), this.add(this.gizmo.rotate = ut(D)), this.add(this.gizmo.scale = ut(Gt2)), this.add(this.picker.translate = ut(kt)), this.add(this.picker.rotate = ut(j)), this.add(this.picker.scale = ut(Kt)), this.add(this.helper.translate = ut(k)), this.add(this.helper.rotate = ut(At)), this.add(this.helper.scale = ut(Jt)), this.picker.translate.visible = false, this.picker.rotate.visible = false, this.picker.scale.visible = false;
  }
};
var Po = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({
        visible: false,
        wireframe: true,
        side: DoubleSide,
        transparent: true,
        opacity: 0.1,
        toneMapped: false
      })
    ), w(this, "isTransformControlsPlane", true), w(this, "type", "TransformControlsPlane"), w(this, "unitX", new Vector3(1, 0, 0)), w(this, "unitY", new Vector3(0, 1, 0)), w(this, "unitZ", new Vector3(0, 0, 1)), w(this, "tempVector", new Vector3()), w(this, "dirVector", new Vector3()), w(this, "alignVector", new Vector3()), w(this, "tempMatrix", new Matrix4()), w(this, "identityQuaternion", new Quaternion()), w(this, "cameraQuaternion", new Quaternion()), w(this, "worldPosition", new Vector3()), w(this, "worldQuaternion", new Quaternion()), w(this, "eye", new Vector3()), w(this, "axis", null), w(this, "mode", "translate"), w(this, "space", "world"), w(this, "updateMatrixWorld", () => {
      let t2 = this.space;
      switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t2 = "local"), this.unitX.set(1, 0, 0).applyQuaternion(t2 === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitY.set(0, 1, 0).applyQuaternion(t2 === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitZ.set(0, 0, 1).applyQuaternion(t2 === "local" ? this.worldQuaternion : this.identityQuaternion), this.alignVector.copy(this.unitY), this.mode) {
        case "translate":
        case "scale":
          switch (this.axis) {
            case "X":
              this.alignVector.copy(this.eye).cross(this.unitX), this.dirVector.copy(this.unitX).cross(this.alignVector);
              break;
            case "Y":
              this.alignVector.copy(this.eye).cross(this.unitY), this.dirVector.copy(this.unitY).cross(this.alignVector);
              break;
            case "Z":
              this.alignVector.copy(this.eye).cross(this.unitZ), this.dirVector.copy(this.unitZ).cross(this.alignVector);
              break;
            case "XY":
              this.dirVector.copy(this.unitZ);
              break;
            case "YZ":
              this.dirVector.copy(this.unitX);
              break;
            case "XZ":
              this.alignVector.copy(this.unitZ), this.dirVector.copy(this.unitY);
              break;
            case "XYZ":
            case "E":
              this.dirVector.set(0, 0, 0);
              break;
          }
          break;
        case "rotate":
        default:
          this.dirVector.set(0, 0, 0);
      }
      this.dirVector.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (this.tempMatrix.lookAt(this.tempVector.set(0, 0, 0), this.dirVector, this.alignVector), this.quaternion.setFromRotationMatrix(this.tempMatrix)), super.updateMatrixWorld();
    });
  }
};
function So(n2, t2, e, i) {
  var s2;
  return s2 = class extends ShaderMaterial {
    constructor(r2) {
      super({
        vertexShader: t2,
        fragmentShader: e,
        ...r2
      });
      for (const o2 in n2)
        this.uniforms[o2] = new Uniform(n2[o2]), Object.defineProperty(this, o2, {
          get() {
            return this.uniforms[o2].value;
          },
          set(a) {
            this.uniforms[o2].value = a;
          }
        });
      this.uniforms = UniformsUtils.clone(this.uniforms);
    }
  }, s2.key = MathUtils.generateUUID(), s2;
}
var Co = () => parseInt(REVISION.replace(/\D+/g, ""));
var Ao = Co();
function Fi(n2, t2, e) {
  const i = useThree((p) => p.size), s2 = useThree((p) => p.viewport), r2 = typeof n2 == "number" ? n2 : i.width * s2.dpr, o2 = i.height * s2.dpr, a = (typeof n2 == "number" ? e : n2) || {}, {
    samples: l2 = 0,
    depth: c,
    ...h
  } = a, u = I.useMemo(() => {
    const p = new WebGLRenderTarget(r2, o2, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType,
      ...h
    });
    return c && (p.depthTexture = new DepthTexture(r2, o2, FloatType)), p.samples = l2, p;
  }, []);
  return I.useLayoutEffect(() => {
    u.setSize(r2, o2), l2 && (u.samples = l2);
  }, [l2, u, r2, o2]), I.useEffect(() => () => u.dispose(), []), u;
}
var Mo = (n2) => typeof n2 == "function";
var Ro2 = I.forwardRef(({
  envMap: n2,
  resolution: t2 = 256,
  frames: e = 1 / 0,
  children: i,
  makeDefault: s2,
  ...r2
}, o2) => {
  const a = useThree(({
    set: d2
  }) => d2), l2 = useThree(({
    camera: d2
  }) => d2), c = useThree(({
    size: d2
  }) => d2), h = I.useRef(null);
  I.useImperativeHandle(o2, () => h.current, []);
  const u = I.useRef(null), p = Fi(t2);
  I.useLayoutEffect(() => {
    r2.manual || h.current.updateProjectionMatrix();
  }, [c, r2]), I.useLayoutEffect(() => {
    h.current.updateProjectionMatrix();
  }), I.useLayoutEffect(() => {
    if (s2) {
      const d2 = l2;
      return a(() => ({
        camera: h.current
      })), () => a(() => ({
        camera: d2
      }));
    }
  }, [h, s2, a]);
  let y = 0, T = null;
  const b = Mo(i);
  return useFrame((d2) => {
    b && (e === 1 / 0 || y < e) && (u.current.visible = false, d2.gl.setRenderTarget(p), T = d2.scene.background, n2 && (d2.scene.background = n2), d2.gl.render(d2.scene, h.current), d2.scene.background = T, d2.gl.setRenderTarget(null), u.current.visible = true, y++);
  }), I.createElement(I.Fragment, null, I.createElement("orthographicCamera", ye({
    left: c.width / -2,
    right: c.width / 2,
    top: c.height / 2,
    bottom: c.height / -2,
    ref: h
  }, r2), !b && i), I.createElement("group", {
    ref: u
  }, b && i(p.texture)));
});
var wr = I.forwardRef(({
  children: n2,
  domElement: t2,
  onChange: e,
  onMouseDown: i,
  onMouseUp: s2,
  onObjectChange: r2,
  object: o2,
  makeDefault: a,
  camera: l2,
  // Transform
  enabled: c,
  axis: h,
  mode: u,
  translationSnap: p,
  rotationSnap: y,
  scaleSnap: T,
  space: b,
  size: d2,
  showX: v,
  showY: E,
  showZ: S,
  ...M
}, x) => {
  const O = useThree((z) => z.controls), A = useThree((z) => z.gl), Q = useThree((z) => z.events), ht = useThree((z) => z.camera), _t = useThree((z) => z.invalidate), kt = useThree((z) => z.get), k = useThree((z) => z.set), D = l2 || ht, At = t2 || Q.connected || A.domElement, j = I.useMemo(() => new To(D, At), [D, At]), Gt2 = I.useRef(null);
  I.useLayoutEffect(() => (o2 ? j.attach(o2 instanceof Object3D ? o2 : o2.current) : Gt2.current instanceof Object3D && j.attach(Gt2.current), () => void j.detach()), [o2, n2, j]), I.useEffect(() => {
    if (O) {
      const z = (U) => O.enabled = !U.value;
      return j.addEventListener("dragging-changed", z), () => j.removeEventListener("dragging-changed", z);
    }
  }, [j, O]);
  const Kt = I.useRef(void 0), Jt = I.useRef(void 0), ut = I.useRef(void 0), $ = I.useRef(void 0);
  return I.useLayoutEffect(() => void (Kt.current = e), [e]), I.useLayoutEffect(() => void (Jt.current = i), [i]), I.useLayoutEffect(() => void (ut.current = s2), [s2]), I.useLayoutEffect(() => void ($.current = r2), [r2]), I.useEffect(() => {
    const z = (ft) => {
      _t(), Kt.current == null || Kt.current(ft);
    }, U = (ft) => Jt.current == null ? void 0 : Jt.current(ft), dt2 = (ft) => ut.current == null ? void 0 : ut.current(ft), _ = (ft) => $.current == null ? void 0 : $.current(ft);
    return j.addEventListener("change", z), j.addEventListener("mouseDown", U), j.addEventListener("mouseUp", dt2), j.addEventListener("objectChange", _), () => {
      j.removeEventListener("change", z), j.removeEventListener("mouseDown", U), j.removeEventListener("mouseUp", dt2), j.removeEventListener("objectChange", _);
    };
  }, [_t, j]), I.useEffect(() => {
    if (a) {
      const z = kt().controls;
      return k({
        controls: j
      }), () => k({
        controls: z
      });
    }
  }, [a, j]), I.createElement(I.Fragment, null, I.createElement("primitive", {
    ref: x,
    object: j,
    enabled: c,
    axis: h,
    mode: u,
    translationSnap: p,
    rotationSnap: y,
    scaleSnap: T,
    space: b,
    size: d2,
    showX: v,
    showY: E,
    showZ: S
  }), I.createElement("group", ye({
    ref: Gt2
  }, M), n2));
});
var G = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var m = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  SCREEN_PAN: 4,
  OFFSET: 8,
  DOLLY: 16,
  ZOOM: 32,
  TOUCH_ROTATE: 64,
  TOUCH_TRUCK: 128,
  TOUCH_SCREEN_PAN: 256,
  TOUCH_OFFSET: 512,
  TOUCH_DOLLY: 1024,
  TOUCH_ZOOM: 2048,
  TOUCH_DOLLY_TRUCK: 4096,
  TOUCH_DOLLY_SCREEN_PAN: 8192,
  TOUCH_DOLLY_OFFSET: 16384,
  TOUCH_DOLLY_ROTATE: 32768,
  TOUCH_ZOOM_TRUCK: 65536,
  TOUCH_ZOOM_OFFSET: 131072,
  TOUCH_ZOOM_SCREEN_PAN: 262144,
  TOUCH_ZOOM_ROTATE: 524288
});
var we = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function le(n2) {
  return n2.isPerspectiveCamera;
}
function se(n2) {
  return n2.isOrthographicCamera;
}
var xe = Math.PI * 2;
var hs = Math.PI / 2;
var xr = 1e-5;
var Ge = Math.PI / 180;
function zt(n2, t2, e) {
  return Math.max(t2, Math.min(e, n2));
}
function W(n2, t2 = xr) {
  return Math.abs(n2) < t2;
}
function V2(n2, t2, e = xr) {
  return W(n2 - t2, e);
}
function us(n2, t2) {
  return Math.round(n2 / t2) * t2;
}
function Ke(n2) {
  return isFinite(n2) ? n2 : n2 < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function Je(n2) {
  return Math.abs(n2) < Number.MAX_VALUE ? n2 : n2 * (1 / 0);
}
function vi(n2, t2, e, i, s2 = 1 / 0, r2) {
  i = Math.max(1e-4, i);
  const o2 = 2 / i, a = o2 * r2, l2 = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
  let c = n2 - t2;
  const h = t2, u = s2 * i;
  c = zt(c, -u, u), t2 = n2 - c;
  const p = (e.value + o2 * c) * r2;
  e.value = (e.value - o2 * p) * l2;
  let y = t2 + (c + p) * l2;
  return h - n2 > 0 == y > h && (y = h, e.value = (y - h) / r2), y;
}
function ds(n2, t2, e, i, s2 = 1 / 0, r2, o2) {
  i = Math.max(1e-4, i);
  const a = 2 / i, l2 = a * r2, c = 1 / (1 + l2 + 0.48 * l2 * l2 + 0.235 * l2 * l2 * l2);
  let h = t2.x, u = t2.y, p = t2.z, y = n2.x - h, T = n2.y - u, b = n2.z - p;
  const d2 = h, v = u, E = p, S = s2 * i, M = S * S, x = y * y + T * T + b * b;
  if (x > M) {
    const j = Math.sqrt(x);
    y = y / j * S, T = T / j * S, b = b / j * S;
  }
  h = n2.x - y, u = n2.y - T, p = n2.z - b;
  const O = (e.x + a * y) * r2, A = (e.y + a * T) * r2, Q = (e.z + a * b) * r2;
  e.x = (e.x - a * O) * c, e.y = (e.y - a * A) * c, e.z = (e.z - a * Q) * c, o2.x = h + (y + O) * c, o2.y = u + (T + A) * c, o2.z = p + (b + Q) * c;
  const ht = d2 - n2.x, _t = v - n2.y, kt = E - n2.z, k = o2.x - d2, D = o2.y - v, At = o2.z - E;
  return ht * k + _t * D + kt * At > 0 && (o2.x = d2, o2.y = v, o2.z = E, e.x = (o2.x - d2) / r2, e.y = (o2.y - v) / r2, e.z = (o2.z - E) / r2), o2;
}
function Ki(n2, t2) {
  t2.set(0, 0), n2.forEach((e) => {
    t2.x += e.clientX, t2.y += e.clientY;
  }), t2.x /= n2.length, t2.y /= n2.length;
}
function Ji(n2, t2) {
  return se(n2) ? (console.warn(`${t2} is not supported in OrthographicCamera`), true) : false;
}
var zo = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(t2, e) {
    const i = this._listeners;
    i[t2] === void 0 && (i[t2] = []), i[t2].indexOf(e) === -1 && i[t2].push(e);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(t2, e) {
    const i = this._listeners;
    return i[t2] !== void 0 && i[t2].indexOf(e) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(t2, e) {
    const s2 = this._listeners[t2];
    if (s2 !== void 0) {
      const r2 = s2.indexOf(e);
      r2 !== -1 && s2.splice(r2, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(t2) {
    if (!t2) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[t2]) && (this._listeners[t2].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(t2) {
    const i = this._listeners[t2.type];
    if (i !== void 0) {
      t2.target = this;
      const s2 = i.slice(0);
      for (let r2 = 0, o2 = s2.length; r2 < o2; r2++)
        s2[r2].call(this, t2);
    }
  }
};
var tn;
var Ho = "2.10.1";
var wi = 1 / 8;
var Lo = /Mac/.test((tn = globalThis == null ? void 0 : globalThis.navigator) === null || tn === void 0 ? void 0 : tn.platform);
var L;
var fs;
var xi;
var en;
var yt;
var F2;
var N2;
var be;
var ti;
var Ft;
var Yt;
var ce;
var ps;
var ms;
var Et;
var ei2;
var Ee;
var gs;
var nn;
var _s;
var sn;
var rn2;
var bi;
var _e = class Ln extends zo {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(t2) {
    L = t2.THREE, fs = Object.freeze(new L.Vector3(0, 0, 0)), xi = Object.freeze(new L.Vector3(0, 1, 0)), en = Object.freeze(new L.Vector3(0, 0, 1)), yt = new L.Vector2(), F2 = new L.Vector3(), N2 = new L.Vector3(), be = new L.Vector3(), ti = new L.Vector3(), Ft = new L.Vector3(), Yt = new L.Vector3(), ce = new L.Vector3(), ps = new L.Vector3(), ms = new L.Vector3(), Et = new L.Spherical(), ei2 = new L.Spherical(), Ee = new L.Box3(), gs = new L.Box3(), nn = new L.Sphere(), _s = new L.Quaternion(), sn = new L.Quaternion(), rn2 = new L.Matrix4(), bi = new L.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return m;
  }
  /**
   * @deprecated Use `cameraControls.mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.
   */
  set verticalDragToForward(t2) {
    console.warn("camera-controls: `verticalDragToForward` was removed. Use `mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.");
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(t2, e) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = false, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = false, this.truckSpeed = 2, this.dollyToCursor = false, this.dragToOffset = false, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = true, this._state = m.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = true, this._boundaryEnclosesCamera = false, this._needsUpdate = true, this._updatedLastTime = false, this._elementRect = new DOMRect(), this._isDragging = false, this._dragNeedsUpdate = true, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._isUserControllingOffset = false, this._isUserControllingZoom = false, this._lastDollyDirection = we.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new L.Vector3(), this._focalOffsetVelocity = new L.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (v, E, S, M) => {
      let x, O;
      if (le(this._camera)) {
        const A = F2.copy(this._camera.position).sub(this._target), Q = this._camera.getEffectiveFOV() * Ge, ht = A.length() * Math.tan(Q * 0.5);
        x = this.truckSpeed * v * ht / this._elementRect.height, O = this.truckSpeed * E * ht / this._elementRect.height;
      } else if (se(this._camera)) {
        const A = this._camera;
        x = this.truckSpeed * v * (A.right - A.left) / A.zoom / this._elementRect.width, O = this.truckSpeed * E * (A.top - A.bottom) / A.zoom / this._elementRect.height;
      } else
        return;
      M ? (S ? this.setFocalOffset(this._focalOffsetEnd.x + x, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(x, 0, true), this.forward(-O, true)) : S ? this.setFocalOffset(this._focalOffsetEnd.x + x, this._focalOffsetEnd.y + O, this._focalOffsetEnd.z, true) : this.truck(x, O, true);
    }, this._rotateInternal = (v, E) => {
      const S = xe * this.azimuthRotateSpeed * v / this._elementRect.height, M = xe * this.polarRotateSpeed * E / this._elementRect.height;
      this.rotate(S, M, true);
    }, this._dollyInternal = (v, E, S) => {
      const M = Math.pow(0.95, -v * this.dollySpeed), x = this._sphericalEnd.radius, O = this._sphericalEnd.radius * M, A = zt(O, this.minDistance, this.maxDistance), Q = A - O;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(O, true) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(Q, true), this._dollyToNoClamp(A, true)) : this._dollyToNoClamp(A, true), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? O : A) - x, this._dollyControlCoord.set(E, S)), this._lastDollyDirection = Math.sign(-v);
    }, this._zoomInternal = (v, E, S) => {
      const M = Math.pow(0.95, v * this.dollySpeed), x = this._zoom, O = this._zoom * M;
      this.zoomTo(O, true), this.dollyToCursor && (this._changedZoom += O - x, this._dollyControlCoord.set(E, S));
    }, typeof L > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = t2, this._yAxisUpSpace = new L.Quaternion().setFromUnitVectors(this._camera.up, xi), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = m.NONE, this._target = new L.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new L.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new L.Spherical().setFromVector3(F2.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new L.Vector3(),
      new L.Vector3(),
      new L.Vector3(),
      new L.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new L.Box3(new L.Vector3(-1 / 0, -1 / 0, -1 / 0), new L.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new L.Vector2(), this.mouseButtons = {
      left: m.ROTATE,
      middle: m.DOLLY,
      right: m.TRUCK,
      wheel: le(this._camera) ? m.DOLLY : se(this._camera) ? m.ZOOM : m.NONE
    }, this.touches = {
      one: m.TOUCH_ROTATE,
      two: le(this._camera) ? m.TOUCH_DOLLY_TRUCK : se(this._camera) ? m.TOUCH_ZOOM_TRUCK : m.NONE,
      three: m.TOUCH_TRUCK
    };
    const i = new L.Vector2(), s2 = new L.Vector2(), r2 = new L.Vector2(), o2 = (v) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const M = this._domElement.getBoundingClientRect(), x = v.clientX / M.width, O = v.clientY / M.height;
        if (x < this._interactiveArea.left || x > this._interactiveArea.right || O < this._interactiveArea.top || O > this._interactiveArea.bottom)
          return;
      }
      const E = v.pointerType !== "mouse" ? null : (v.buttons & G.LEFT) === G.LEFT ? G.LEFT : (v.buttons & G.MIDDLE) === G.MIDDLE ? G.MIDDLE : (v.buttons & G.RIGHT) === G.RIGHT ? G.RIGHT : null;
      if (E !== null) {
        const M = this._findPointerByMouseButton(E);
        M && this._disposePointer(M);
      }
      if ((v.buttons & G.LEFT) === G.LEFT && this._lockedPointer)
        return;
      const S = {
        pointerId: v.pointerId,
        clientX: v.clientX,
        clientY: v.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: E
      };
      this._activePointers.push(S), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", l2), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", l2), this._isDragging = true, p(v);
    }, a = (v) => {
      v.cancelable && v.preventDefault();
      const E = v.pointerId, S = this._lockedPointer || this._findPointerById(E);
      if (S) {
        if (S.clientX = v.clientX, S.clientY = v.clientY, S.deltaX = v.movementX, S.deltaY = v.movementY, this._state = 0, v.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (v.buttons & G.LEFT) === G.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (v.buttons & G.MIDDLE) === G.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (v.buttons & G.RIGHT) === G.RIGHT && (this._state = this._state | this.mouseButtons.right);
        y();
      }
    }, l2 = (v) => {
      const E = this._findPointerById(v.pointerId);
      if (!(E && E === this._lockedPointer)) {
        if (E && this._disposePointer(E), v.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = m.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = m.NONE;
        T();
      }
    };
    let c = -1;
    const h = (v) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === m.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const O = this._domElement.getBoundingClientRect(), A = v.clientX / O.width, Q = v.clientY / O.height;
        if (A < this._interactiveArea.left || A > this._interactiveArea.right || Q < this._interactiveArea.top || Q > this._interactiveArea.bottom)
          return;
      }
      if (v.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === m.ROTATE || this.mouseButtons.wheel === m.TRUCK) {
        const O = performance.now();
        c - O < 1e3 && this._getClientRect(this._elementRect), c = O;
      }
      const E = Lo ? -1 : -3, S = v.deltaMode === 1 || v.ctrlKey ? v.deltaY / E : v.deltaY / (E * 10), M = this.dollyToCursor ? (v.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, x = this.dollyToCursor ? (v.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case m.ROTATE: {
          this._rotateInternal(v.deltaX, v.deltaY), this._isUserControllingRotate = true;
          break;
        }
        case m.TRUCK: {
          this._truckInternal(v.deltaX, v.deltaY, false, false), this._isUserControllingTruck = true;
          break;
        }
        case m.SCREEN_PAN: {
          this._truckInternal(v.deltaX, v.deltaY, false, true), this._isUserControllingTruck = true;
          break;
        }
        case m.OFFSET: {
          this._truckInternal(v.deltaX, v.deltaY, true, false), this._isUserControllingOffset = true;
          break;
        }
        case m.DOLLY: {
          this._dollyInternal(-S, M, x), this._isUserControllingDolly = true;
          break;
        }
        case m.ZOOM: {
          this._zoomInternal(-S, M, x), this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, u = (v) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === Ln.ACTION.NONE) {
          const E = v instanceof PointerEvent ? v.pointerId : 0, S = this._findPointerById(E);
          S && this._disposePointer(S), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", l2);
          return;
        }
        v.preventDefault();
      }
    }, p = (v) => {
      if (!this._enabled)
        return;
      if (Ki(this._activePointers, yt), this._getClientRect(this._elementRect), i.copy(yt), s2.copy(yt), this._activePointers.length >= 2) {
        const S = yt.x - this._activePointers[1].clientX, M = yt.y - this._activePointers[1].clientY, x = Math.sqrt(S * S + M * M);
        r2.set(0, x);
        const O = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, A = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        s2.set(O, A);
      }
      if (this._state = 0, !v)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in v && v.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (v.buttons & G.LEFT) === G.LEFT && (this._state = this._state | this.mouseButtons.left), (v.buttons & G.MIDDLE) === G.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (v.buttons & G.RIGHT) === G.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & m.ROTATE) === m.ROTATE || (this._state & m.TOUCH_ROTATE) === m.TOUCH_ROTATE || (this._state & m.TOUCH_DOLLY_ROTATE) === m.TOUCH_DOLLY_ROTATE || (this._state & m.TOUCH_ZOOM_ROTATE) === m.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & m.TRUCK) === m.TRUCK || (this._state & m.SCREEN_PAN) === m.SCREEN_PAN || (this._state & m.TOUCH_TRUCK) === m.TOUCH_TRUCK || (this._state & m.TOUCH_SCREEN_PAN) === m.TOUCH_SCREEN_PAN || (this._state & m.TOUCH_DOLLY_TRUCK) === m.TOUCH_DOLLY_TRUCK || (this._state & m.TOUCH_DOLLY_SCREEN_PAN) === m.TOUCH_DOLLY_SCREEN_PAN || (this._state & m.TOUCH_ZOOM_TRUCK) === m.TOUCH_ZOOM_TRUCK || (this._state & m.TOUCH_ZOOM_SCREEN_PAN) === m.TOUCH_DOLLY_SCREEN_PAN) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & m.DOLLY) === m.DOLLY || (this._state & m.TOUCH_DOLLY) === m.TOUCH_DOLLY || (this._state & m.TOUCH_DOLLY_TRUCK) === m.TOUCH_DOLLY_TRUCK || (this._state & m.TOUCH_DOLLY_SCREEN_PAN) === m.TOUCH_DOLLY_SCREEN_PAN || (this._state & m.TOUCH_DOLLY_OFFSET) === m.TOUCH_DOLLY_OFFSET || (this._state & m.TOUCH_DOLLY_ROTATE) === m.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & m.ZOOM) === m.ZOOM || (this._state & m.TOUCH_ZOOM) === m.TOUCH_ZOOM || (this._state & m.TOUCH_ZOOM_TRUCK) === m.TOUCH_ZOOM_TRUCK || (this._state & m.TOUCH_ZOOM_SCREEN_PAN) === m.TOUCH_ZOOM_SCREEN_PAN || (this._state & m.TOUCH_ZOOM_OFFSET) === m.TOUCH_ZOOM_OFFSET || (this._state & m.TOUCH_ZOOM_ROTATE) === m.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & m.OFFSET) === m.OFFSET || (this._state & m.TOUCH_OFFSET) === m.TOUCH_OFFSET || (this._state & m.TOUCH_DOLLY_OFFSET) === m.TOUCH_DOLLY_OFFSET || (this._state & m.TOUCH_ZOOM_OFFSET) === m.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, y = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false, Ki(this._activePointers, yt);
      const E = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, S = E ? -E.deltaX : s2.x - yt.x, M = E ? -E.deltaY : s2.y - yt.y;
      if (s2.copy(yt), ((this._state & m.ROTATE) === m.ROTATE || (this._state & m.TOUCH_ROTATE) === m.TOUCH_ROTATE || (this._state & m.TOUCH_DOLLY_ROTATE) === m.TOUCH_DOLLY_ROTATE || (this._state & m.TOUCH_ZOOM_ROTATE) === m.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(S, M), this._isUserControllingRotate = true), (this._state & m.DOLLY) === m.DOLLY || (this._state & m.ZOOM) === m.ZOOM) {
        const x = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, O = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, A = this.dollyDragInverted ? -1 : 1;
        (this._state & m.DOLLY) === m.DOLLY ? (this._dollyInternal(A * M * wi, x, O), this._isUserControllingDolly = true) : (this._zoomInternal(A * M * wi, x, O), this._isUserControllingZoom = true);
      }
      if ((this._state & m.TOUCH_DOLLY) === m.TOUCH_DOLLY || (this._state & m.TOUCH_ZOOM) === m.TOUCH_ZOOM || (this._state & m.TOUCH_DOLLY_TRUCK) === m.TOUCH_DOLLY_TRUCK || (this._state & m.TOUCH_ZOOM_TRUCK) === m.TOUCH_ZOOM_TRUCK || (this._state & m.TOUCH_DOLLY_SCREEN_PAN) === m.TOUCH_DOLLY_SCREEN_PAN || (this._state & m.TOUCH_ZOOM_SCREEN_PAN) === m.TOUCH_ZOOM_SCREEN_PAN || (this._state & m.TOUCH_DOLLY_OFFSET) === m.TOUCH_DOLLY_OFFSET || (this._state & m.TOUCH_ZOOM_OFFSET) === m.TOUCH_ZOOM_OFFSET || (this._state & m.TOUCH_DOLLY_ROTATE) === m.TOUCH_DOLLY_ROTATE || (this._state & m.TOUCH_ZOOM_ROTATE) === m.TOUCH_ZOOM_ROTATE) {
        const x = yt.x - this._activePointers[1].clientX, O = yt.y - this._activePointers[1].clientY, A = Math.sqrt(x * x + O * O), Q = r2.y - A;
        r2.set(0, A);
        const ht = this.dollyToCursor ? (s2.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, _t = this.dollyToCursor ? (s2.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & m.TOUCH_DOLLY) === m.TOUCH_DOLLY || (this._state & m.TOUCH_DOLLY_ROTATE) === m.TOUCH_DOLLY_ROTATE || (this._state & m.TOUCH_DOLLY_TRUCK) === m.TOUCH_DOLLY_TRUCK || (this._state & m.TOUCH_DOLLY_SCREEN_PAN) === m.TOUCH_DOLLY_SCREEN_PAN || (this._state & m.TOUCH_DOLLY_OFFSET) === m.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(Q * wi, ht, _t), this._isUserControllingDolly = true) : (this._zoomInternal(Q * wi, ht, _t), this._isUserControllingZoom = true);
      }
      ((this._state & m.TRUCK) === m.TRUCK || (this._state & m.TOUCH_TRUCK) === m.TOUCH_TRUCK || (this._state & m.TOUCH_DOLLY_TRUCK) === m.TOUCH_DOLLY_TRUCK || (this._state & m.TOUCH_ZOOM_TRUCK) === m.TOUCH_ZOOM_TRUCK) && (this._truckInternal(S, M, false, false), this._isUserControllingTruck = true), ((this._state & m.SCREEN_PAN) === m.SCREEN_PAN || (this._state & m.TOUCH_SCREEN_PAN) === m.TOUCH_SCREEN_PAN || (this._state & m.TOUCH_DOLLY_SCREEN_PAN) === m.TOUCH_DOLLY_SCREEN_PAN || (this._state & m.TOUCH_ZOOM_SCREEN_PAN) === m.TOUCH_ZOOM_SCREEN_PAN) && (this._truckInternal(S, M, false, true), this._isUserControllingTruck = true), ((this._state & m.OFFSET) === m.OFFSET || (this._state & m.TOUCH_OFFSET) === m.TOUCH_OFFSET || (this._state & m.TOUCH_DOLLY_OFFSET) === m.TOUCH_DOLLY_OFFSET || (this._state & m.TOUCH_ZOOM_OFFSET) === m.TOUCH_ZOOM_OFFSET) && (this._truckInternal(S, M, true, false), this._isUserControllingOffset = true), this.dispatchEvent({ type: "control" });
    }, T = () => {
      Ki(this._activePointers, yt), s2.copy(yt), this._dragNeedsUpdate = false, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = false), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", l2), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", l2), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", b), this._domElement.ownerDocument.addEventListener("pointerlockerror", d2), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", l2), p());
    }, this.unlockPointer = () => {
      var v, E, S;
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), (v = this._domElement) === null || v === void 0 || v.ownerDocument.exitPointerLock(), (E = this._domElement) === null || E === void 0 || E.ownerDocument.removeEventListener("pointerlockchange", b), (S = this._domElement) === null || S === void 0 || S.ownerDocument.removeEventListener("pointerlockerror", d2), this.cancel();
    };
    const b = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, d2 = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (v) => {
      this._domElement = v, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", o2), this._domElement.addEventListener("pointercancel", l2), this._domElement.addEventListener("wheel", h, { passive: false }), this._domElement.addEventListener("contextmenu", u);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", o2), this._domElement.removeEventListener("pointercancel", l2), this._domElement.removeEventListener("wheel", h, { passive: false }), this._domElement.removeEventListener("contextmenu", u), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", l2), this._domElement.ownerDocument.removeEventListener("pointerlockchange", b), this._domElement.ownerDocument.removeEventListener("pointerlockerror", d2));
    }, this.cancel = () => {
      this._state !== m.NONE && (this._state = m.NONE, this._activePointers.length = 0, T());
    }, e && this.connect(e), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(t2) {
    this._camera = t2, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(t2) {
    this._enabled = t2, this._domElement && (t2 ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(t2) {
    this._spherical.radius === t2 && this._sphericalEnd.radius === t2 || (this._spherical.radius = t2, this._sphericalEnd.radius = t2, this._needsUpdate = true);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(t2) {
    this._spherical.theta === t2 && this._sphericalEnd.theta === t2 || (this._spherical.theta = t2, this._sphericalEnd.theta = t2, this._needsUpdate = true);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(t2) {
    this._spherical.phi === t2 && this._sphericalEnd.phi === t2 || (this._spherical.phi = t2, this._sphericalEnd.phi = t2, this._needsUpdate = true);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(t2) {
    this._boundaryEnclosesCamera = t2, this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(t2) {
    this._interactiveArea.width = zt(t2.width, 0, 1), this._interactiveArea.height = zt(t2.height, 0, 1), this._interactiveArea.x = zt(t2.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = zt(t2.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(t2, e) {
    super.addEventListener(t2, e);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(t2, e) {
    super.removeEventListener(t2, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(t2, e, i = false) {
    return this.rotateTo(this._sphericalEnd.theta + t2, this._sphericalEnd.phi + e, i);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(t2, e = false) {
    return this.rotateTo(t2, this._sphericalEnd.phi, e);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(t2, e = false) {
    return this.rotateTo(this._sphericalEnd.theta, t2, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(t2, e, i = false) {
    this._isUserControllingRotate = false;
    const s2 = zt(t2, this.minAzimuthAngle, this.maxAzimuthAngle), r2 = zt(e, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = s2, this._sphericalEnd.phi = r2, this._sphericalEnd.makeSafe(), this._needsUpdate = true, i || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const o2 = !i || V2(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && V2(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(o2);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(t2, e = false) {
    return this.dollyTo(this._sphericalEnd.radius - t2, e);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(t2, e = false) {
    return this._isUserControllingDolly = false, this._lastDollyDirection = we.NONE, this._changedDolly = 0, this._dollyToNoClamp(zt(t2, this.minDistance, this.maxDistance), e);
  }
  _dollyToNoClamp(t2, e = false) {
    const i = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const o2 = this._collisionTest(), a = V2(o2, this._spherical.radius);
      if (!(i > t2) && a)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(t2, o2);
    } else
      this._sphericalEnd.radius = t2;
    this._needsUpdate = true, e || (this._spherical.radius = this._sphericalEnd.radius);
    const r2 = !e || V2(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(r2);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(t2, e = false) {
    this._targetEnd.add(this._getCameraDirection(ti).multiplyScalar(t2)), e || this._target.copy(this._targetEnd);
    const i = !e || V2(this._target.x, this._targetEnd.x, this.restThreshold) && V2(this._target.y, this._targetEnd.y, this.restThreshold) && V2(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(t2, e = false) {
    return this.zoomTo(this._zoomEnd + t2, e);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(t2, e = false) {
    this._isUserControllingZoom = false, this._zoomEnd = zt(t2, this.minZoom, this.maxZoom), this._needsUpdate = true, e || (this._zoom = this._zoomEnd);
    const i = !e || V2(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(i);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(t2, e, i = false) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(t2, e, i);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(t2, e, i = false) {
    this._camera.updateMatrix(), Ft.setFromMatrixColumn(this._camera.matrix, 0), Yt.setFromMatrixColumn(this._camera.matrix, 1), Ft.multiplyScalar(t2), Yt.multiplyScalar(-e);
    const s2 = F2.copy(Ft).add(Yt), r2 = N2.copy(this._targetEnd).add(s2);
    return this.moveTo(r2.x, r2.y, r2.z, i);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(t2, e = false) {
    F2.setFromMatrixColumn(this._camera.matrix, 0), F2.crossVectors(this._camera.up, F2), F2.multiplyScalar(t2);
    const i = N2.copy(this._targetEnd).add(F2);
    return this.moveTo(i.x, i.y, i.z, e);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(t2, e = false) {
    return F2.copy(this._camera.up).multiplyScalar(t2), this.moveTo(this._targetEnd.x + F2.x, this._targetEnd.y + F2.y, this._targetEnd.z + F2.z, e);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(t2, e, i, s2 = false) {
    this._isUserControllingTruck = false;
    const r2 = F2.set(t2, e, i).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, r2, this.boundaryFriction), this._needsUpdate = true, s2 || this._target.copy(this._targetEnd);
    const o2 = !s2 || V2(this._target.x, this._targetEnd.x, this.restThreshold) && V2(this._target.y, this._targetEnd.y, this.restThreshold) && V2(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(o2);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(t2, e, i, s2 = false) {
    const a = F2.set(t2, e, i).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(a.x, a.y, a.z, s2);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(t2, e, { cover: i = false, paddingLeft: s2 = 0, paddingRight: r2 = 0, paddingBottom: o2 = 0, paddingTop: a = 0 } = {}) {
    const l2 = [], c = t2.isBox3 ? Ee.copy(t2) : Ee.setFromObject(t2);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const h = us(this._sphericalEnd.theta, hs), u = us(this._sphericalEnd.phi, hs);
    l2.push(this.rotateTo(h, u, e));
    const p = F2.setFromSpherical(this._sphericalEnd).normalize(), y = _s.setFromUnitVectors(p, en), T = V2(Math.abs(p.y), 1);
    T && y.multiply(sn.setFromAxisAngle(xi, h)), y.multiply(this._yAxisUpSpaceInverse);
    const b = gs.makeEmpty();
    N2.copy(c.min).applyQuaternion(y), b.expandByPoint(N2), N2.copy(c.min).setX(c.max.x).applyQuaternion(y), b.expandByPoint(N2), N2.copy(c.min).setY(c.max.y).applyQuaternion(y), b.expandByPoint(N2), N2.copy(c.max).setZ(c.min.z).applyQuaternion(y), b.expandByPoint(N2), N2.copy(c.min).setZ(c.max.z).applyQuaternion(y), b.expandByPoint(N2), N2.copy(c.max).setY(c.min.y).applyQuaternion(y), b.expandByPoint(N2), N2.copy(c.max).setX(c.min.x).applyQuaternion(y), b.expandByPoint(N2), N2.copy(c.max).applyQuaternion(y), b.expandByPoint(N2), b.min.x -= s2, b.min.y -= o2, b.max.x += r2, b.max.y += a, y.setFromUnitVectors(en, p), T && y.premultiply(sn.invert()), y.premultiply(this._yAxisUpSpace);
    const d2 = b.getSize(F2), v = b.getCenter(N2).applyQuaternion(y);
    if (le(this._camera)) {
      const E = this.getDistanceToFitBox(d2.x, d2.y, d2.z, i);
      l2.push(this.moveTo(v.x, v.y, v.z, e)), l2.push(this.dollyTo(E, e)), l2.push(this.setFocalOffset(0, 0, 0, e));
    } else if (se(this._camera)) {
      const E = this._camera, S = E.right - E.left, M = E.top - E.bottom, x = i ? Math.max(S / d2.x, M / d2.y) : Math.min(S / d2.x, M / d2.y);
      l2.push(this.moveTo(v.x, v.y, v.z, e)), l2.push(this.zoomTo(x, e)), l2.push(this.setFocalOffset(0, 0, 0, e));
    }
    return Promise.all(l2);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(t2, e) {
    const i = [], r2 = "isObject3D" in t2 ? Ln.createBoundingSphere(t2, nn) : nn.copy(t2);
    if (i.push(this.moveTo(r2.center.x, r2.center.y, r2.center.z, e)), le(this._camera)) {
      const o2 = this.getDistanceToFitSphere(r2.radius);
      i.push(this.dollyTo(o2, e));
    } else if (se(this._camera)) {
      const o2 = this._camera.right - this._camera.left, a = this._camera.top - this._camera.bottom, l2 = 2 * r2.radius, c = Math.min(o2 / l2, a / l2);
      i.push(this.zoomTo(c, e));
    }
    return i.push(this.setFocalOffset(0, 0, 0, e)), Promise.all(i);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(t2, e, i, s2, r2, o2, a = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = we.NONE, this._changedDolly = 0;
    const l2 = N2.set(s2, r2, o2), c = F2.set(t2, e, i);
    this._targetEnd.copy(l2), this._sphericalEnd.setFromVector3(c.sub(l2).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = true, a || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const h = !a || V2(this._target.x, this._targetEnd.x, this.restThreshold) && V2(this._target.y, this._targetEnd.y, this.restThreshold) && V2(this._target.z, this._targetEnd.z, this.restThreshold) && V2(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && V2(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && V2(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(h);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(t2, e, i, s2, r2, o2, a, l2, c, h, u, p, y, T = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = we.NONE, this._changedDolly = 0;
    const b = F2.set(s2, r2, o2), d2 = N2.set(t2, e, i);
    Et.setFromVector3(d2.sub(b).applyQuaternion(this._yAxisUpSpace));
    const v = be.set(h, u, p), E = N2.set(a, l2, c);
    ei2.setFromVector3(E.sub(v).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(b.lerp(v, y));
    const S = ei2.theta - Et.theta, M = ei2.phi - Et.phi, x = ei2.radius - Et.radius;
    this._sphericalEnd.set(Et.radius + x * y, Et.phi + M * y, Et.theta + S * y), this.normalizeRotations(), this._needsUpdate = true, T || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const O = !T || V2(this._target.x, this._targetEnd.x, this.restThreshold) && V2(this._target.y, this._targetEnd.y, this.restThreshold) && V2(this._target.z, this._targetEnd.z, this.restThreshold) && V2(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && V2(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && V2(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(O);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(t2, e, i, s2 = false) {
    return this.setLookAt(t2, e, i, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, s2);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(t2, e, i, s2 = false) {
    const r2 = this.getPosition(F2), o2 = this.setLookAt(r2.x, r2.y, r2.z, t2, e, i, s2);
    return this._sphericalEnd.phi = zt(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), o2;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(t2, e, i, s2 = false) {
    this._isUserControllingOffset = false, this._focalOffsetEnd.set(t2, e, i), this._needsUpdate = true, s2 || this._focalOffset.copy(this._focalOffsetEnd);
    const r2 = !s2 || V2(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && V2(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && V2(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(r2);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(t2, e, i) {
    this._camera.updateMatrixWorld(), Ft.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), Yt.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), ce.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const s2 = F2.set(t2, e, i), r2 = s2.distanceTo(this._camera.position), o2 = s2.sub(this._camera.position);
    Ft.multiplyScalar(o2.x), Yt.multiplyScalar(o2.y), ce.multiplyScalar(o2.z), F2.copy(Ft).add(Yt).add(ce), F2.z = F2.z + r2, this.dollyTo(r2, false), this.setFocalOffset(-F2.x, F2.y, -F2.z, false), this.moveTo(t2, e, i, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(t2) {
    if (!t2) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = true;
      return;
    }
    this._boundary.copy(t2), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(t2, e, i, s2) {
    if (t2 === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new L.Vector4(), typeof t2 == "number" ? this._viewport.set(t2, e, i, s2) : this._viewport.copy(t2);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(t2, e, i, s2 = false) {
    if (Ji(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const r2 = t2 / e, o2 = this._camera.getEffectiveFOV() * Ge, a = this._camera.aspect;
    return ((s2 ? r2 > a : r2 < a) ? e : t2 / a) * 0.5 / Math.tan(o2 * 0.5) + i * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(t2) {
    if (Ji(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const e = this._camera.getEffectiveFOV() * Ge, i = Math.atan(Math.tan(e * 0.5) * this._camera.aspect) * 2, s2 = 1 < this._camera.aspect ? e : i;
    return t2 / Math.sin(s2 * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(t2, e = true) {
    return (t2 && t2.isVector3 ? t2 : new L.Vector3()).copy(e ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(t2, e = true) {
    return (t2 && t2.isVector3 ? t2 : new L.Vector3()).setFromSpherical(e ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(e ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(t2, e = true) {
    return (t2 || new L.Spherical()).copy(e ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(t2, e = true) {
    return (t2 && t2.isVector3 ? t2 : new L.Vector3()).copy(e ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % xe, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += xe), this._spherical.theta += xe * Math.round((this._sphericalEnd.theta - this._spherical.theta) / xe);
  }
  /**
   * stop all transitions.
   */
  stop() {
    this._focalOffset.copy(this._focalOffsetEnd), this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd), this._zoom = this._zoomEnd;
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(t2 = false) {
    if (!V2(this._camera.up.x, this._cameraUp0.x) || !V2(this._camera.up.y, this._cameraUp0.y) || !V2(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const i = this.getPosition(F2);
      this.updateCameraUp(), this.setPosition(i.x, i.y, i.z);
    }
    const e = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, t2),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, t2),
      this.zoomTo(this._zoom0, t2)
    ];
    return Promise.all(e);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, xi), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const t2 = F2.subVectors(this._target, this._camera.position).normalize(), e = N2.crossVectors(t2, this._camera.up);
    this._camera.up.crossVectors(e, t2).normalize(), this._camera.updateMatrixWorld();
    const i = this.getPosition(F2);
    this.updateCameraUp(), this.setPosition(i.x, i.y, i.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(t2) {
    const e = this._sphericalEnd.theta - this._spherical.theta, i = this._sphericalEnd.phi - this._spherical.phi, s2 = this._sphericalEnd.radius - this._spherical.radius, r2 = ps.subVectors(this._targetEnd, this._target), o2 = ms.subVectors(this._focalOffsetEnd, this._focalOffset), a = this._zoomEnd - this._zoom;
    if (W(e))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const u = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = vi(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, u, 1 / 0, t2), this._needsUpdate = true;
    }
    if (W(i))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const u = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = vi(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, u, 1 / 0, t2), this._needsUpdate = true;
    }
    if (W(s2))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const u = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = vi(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, u, this.maxSpeed, t2), this._needsUpdate = true;
    }
    if (W(r2.x) && W(r2.y) && W(r2.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const u = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      ds(this._target, this._targetEnd, this._targetVelocity, u, this.maxSpeed, t2, this._target), this._needsUpdate = true;
    }
    if (W(o2.x) && W(o2.y) && W(o2.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const u = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      ds(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, u, this.maxSpeed, t2, this._focalOffset), this._needsUpdate = true;
    }
    if (W(a))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const u = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = vi(this._zoom, this._zoomEnd, this._zoomVelocity, u, 1 / 0, t2);
    }
    if (this.dollyToCursor) {
      if (le(this._camera) && this._changedDolly !== 0) {
        const u = this._spherical.radius - this._lastDistance, p = this._camera, y = this._getCameraDirection(ti), T = F2.copy(y).cross(p.up).normalize();
        T.lengthSq() === 0 && (T.x = 1);
        const b = N2.crossVectors(T, y), d2 = this._sphericalEnd.radius * Math.tan(p.getEffectiveFOV() * Ge * 0.5), E = (this._sphericalEnd.radius - u - this._sphericalEnd.radius) / this._sphericalEnd.radius, S = be.copy(this._targetEnd).add(T.multiplyScalar(this._dollyControlCoord.x * d2 * p.aspect)).add(b.multiplyScalar(this._dollyControlCoord.y * d2)), M = F2.copy(this._targetEnd).lerp(S, E), x = this._lastDollyDirection === we.IN && this._spherical.radius <= this.minDistance, O = this._lastDollyDirection === we.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (x || O)) {
          this._sphericalEnd.radius -= u, this._spherical.radius -= u;
          const Q = N2.copy(y).multiplyScalar(-u);
          M.add(Q);
        }
        this._boundary.clampPoint(M, M);
        const A = N2.subVectors(M, this._targetEnd);
        this._targetEnd.copy(M), this._target.add(A), this._changedDolly -= u, W(this._changedDolly) && (this._changedDolly = 0);
      } else if (se(this._camera) && this._changedZoom !== 0) {
        const u = this._zoom - this._lastZoom, p = this._camera, y = F2.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (p.near + p.far) / (p.near - p.far)).unproject(p), T = N2.set(0, 0, -1).applyQuaternion(p.quaternion), b = be.copy(y).add(T.multiplyScalar(-y.dot(p.up))), v = -(this._zoom - u - this._zoom) / this._zoom, E = this._getCameraDirection(ti), S = this._targetEnd.dot(E), M = F2.copy(this._targetEnd).lerp(b, v), x = M.dot(E), O = E.multiplyScalar(x - S);
        M.sub(O), this._boundary.clampPoint(M, M);
        const A = N2.subVectors(M, this._targetEnd);
        this._targetEnd.copy(M), this._target.add(A), this._changedZoom -= u, W(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true), this._dragNeedsUpdate = true;
    const l2 = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, l2), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!W(this._focalOffset.x) || !W(this._focalOffset.y) || !W(this._focalOffset.z)) && (Ft.setFromMatrixColumn(this._camera.matrix, 0), Yt.setFromMatrixColumn(this._camera.matrix, 1), ce.setFromMatrixColumn(this._camera.matrix, 2), Ft.multiplyScalar(this._focalOffset.x), Yt.multiplyScalar(-this._focalOffset.y), ce.multiplyScalar(this._focalOffset.z), F2.copy(Ft).add(Yt).add(ce), this._camera.position.add(F2), this._camera.updateMatrixWorld()), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), F2.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const h = this._needsUpdate;
    return h && !this._updatedLastTime ? (this._hasRested = false, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : h ? (this.dispatchEvent({ type: "update" }), W(e, this.restThreshold) && W(i, this.restThreshold) && W(s2, this.restThreshold) && W(r2.x, this.restThreshold) && W(r2.y, this.restThreshold) && W(r2.z, this.restThreshold) && W(o2.x, this.restThreshold) && W(o2.y, this.restThreshold) && W(o2.z, this.restThreshold) && W(a, this.restThreshold) && !this._hasRested && (this._hasRested = true, this.dispatchEvent({ type: "rest" }))) : !h && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = h, this._needsUpdate = false, h;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: Ke(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: Ke(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: Ke(this.maxPolarAngle),
      minAzimuthAngle: Ke(this.minAzimuthAngle),
      maxAzimuthAngle: Ke(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      target: this._targetEnd.toArray(),
      position: F2.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(t2, e = false) {
    const i = JSON.parse(t2);
    this.enabled = i.enabled, this.minDistance = i.minDistance, this.maxDistance = Je(i.maxDistance), this.minZoom = i.minZoom, this.maxZoom = Je(i.maxZoom), this.minPolarAngle = i.minPolarAngle, this.maxPolarAngle = Je(i.maxPolarAngle), this.minAzimuthAngle = Je(i.minAzimuthAngle), this.maxAzimuthAngle = Je(i.maxAzimuthAngle), this.smoothTime = i.smoothTime, this.draggingSmoothTime = i.draggingSmoothTime, this.dollySpeed = i.dollySpeed, this.truckSpeed = i.truckSpeed, this.dollyToCursor = i.dollyToCursor, this._target0.fromArray(i.target0), this._position0.fromArray(i.position0), this._zoom0 = i.zoom0, this._focalOffset0.fromArray(i.focalOffset0), this.moveTo(i.target[0], i.target[1], i.target[2], e), Et.setFromVector3(F2.fromArray(i.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(Et.theta, Et.phi, e), this.dollyTo(Et.radius, e), this.zoomTo(i.zoom, e), this.setFocalOffset(i.focalOffset[0], i.focalOffset[1], i.focalOffset[2], e), this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(t2) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    t2.setAttribute("data-camera-controls-version", Ho), this._addAllEventListeners(t2), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(t2) {
    return t2.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(t2) {
    return this._getTargetDirection(t2).negate();
  }
  _findPointerById(t2) {
    return this._activePointers.find((e) => e.pointerId === t2);
  }
  _findPointerByMouseButton(t2) {
    return this._activePointers.find((e) => e.mouseButton === t2);
  }
  _disposePointer(t2) {
    this._activePointers.splice(this._activePointers.indexOf(t2), 1);
  }
  _encloseToBoundary(t2, e, i) {
    const s2 = e.lengthSq();
    if (s2 === 0)
      return t2;
    const r2 = N2.copy(e).add(t2), a = this._boundary.clampPoint(r2, be).sub(r2), l2 = a.lengthSq();
    if (l2 === 0)
      return t2.add(e);
    if (l2 === s2)
      return t2;
    if (i === 0)
      return t2.add(e).add(a);
    {
      const c = 1 + i * l2 / e.dot(a);
      return t2.add(N2.copy(e).multiplyScalar(c)).add(a.multiplyScalar(1 - i));
    }
  }
  _updateNearPlaneCorners() {
    if (le(this._camera)) {
      const t2 = this._camera, e = t2.near, i = t2.getEffectiveFOV() * Ge, s2 = Math.tan(i * 0.5) * e, r2 = s2 * t2.aspect;
      this._nearPlaneCorners[0].set(-r2, -s2, 0), this._nearPlaneCorners[1].set(r2, -s2, 0), this._nearPlaneCorners[2].set(r2, s2, 0), this._nearPlaneCorners[3].set(-r2, s2, 0);
    } else if (se(this._camera)) {
      const t2 = this._camera, e = 1 / t2.zoom, i = t2.left * e, s2 = t2.right * e, r2 = t2.top * e, o2 = t2.bottom * e;
      this._nearPlaneCorners[0].set(i, r2, 0), this._nearPlaneCorners[1].set(s2, r2, 0), this._nearPlaneCorners[2].set(s2, o2, 0), this._nearPlaneCorners[3].set(i, o2, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let t2 = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || Ji(this._camera, "_collisionTest"))
      return t2;
    const i = this._getTargetDirection(ti);
    rn2.lookAt(fs, i, this._camera.up);
    for (let s2 = 0; s2 < 4; s2++) {
      const r2 = N2.copy(this._nearPlaneCorners[s2]);
      r2.applyMatrix4(rn2);
      const o2 = be.addVectors(this._target, r2);
      bi.set(o2, i), bi.far = this._spherical.radius + 1;
      const a = bi.intersectObjects(this.colliderMeshes);
      a.length !== 0 && a[0].distance < t2 && (t2 = a[0].distance);
    }
    return t2;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(t2) {
    if (!this._domElement)
      return;
    const e = this._domElement.getBoundingClientRect();
    return t2.x = e.left, t2.y = e.top, this._viewport ? (t2.x += this._viewport.x, t2.y += e.height - this._viewport.w - this._viewport.y, t2.width = this._viewport.z, t2.height = this._viewport.w) : (t2.width = e.width, t2.height = e.height), t2;
  }
  _createOnRestPromise(t2) {
    return t2 ? Promise.resolve() : (this._hasRested = false, this.dispatchEvent({ type: "transitionstart" }), new Promise((e) => {
      const i = () => {
        this.removeEventListener("rest", i), e();
      };
      this.addEventListener("rest", i);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(t2) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(t2) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(t2) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(t2, e = new L.Sphere()) {
    const i = e, s2 = i.center;
    Ee.makeEmpty(), t2.traverseVisible((o2) => {
      o2.isMesh && Ee.expandByObject(o2);
    }), Ee.getCenter(s2);
    let r2 = 0;
    return t2.traverseVisible((o2) => {
      if (!o2.isMesh)
        return;
      const a = o2;
      if (!a.geometry)
        return;
      const l2 = a.geometry.clone();
      l2.applyMatrix4(a.matrixWorld);
      const h = l2.attributes.position;
      for (let u = 0, p = h.count; u < p; u++)
        F2.fromBufferAttribute(h, u), r2 = Math.max(r2, s2.distanceToSquared(F2));
    }), i.radius = Math.sqrt(r2), i;
  }
};
var Io = (0, import_react.forwardRef)((n2, t2) => {
  (0, import_react.useMemo)(() => {
    const D = {
      Box3,
      MathUtils: {
        clamp: MathUtils.clamp
      },
      Matrix4,
      Quaternion,
      Raycaster,
      Sphere,
      Spherical,
      Vector2,
      Vector3,
      Vector4
    };
    _e.install({
      THREE: D
    }), extend({
      CameraControlsImpl: _e
    });
  }, []);
  const {
    camera: e,
    domElement: i,
    makeDefault: s2,
    onControlStart: r2,
    onControl: o2,
    onControlEnd: a,
    onTransitionStart: l2,
    onUpdate: c,
    onWake: h,
    onRest: u,
    onSleep: p,
    onStart: y,
    onEnd: T,
    onChange: b,
    regress: d2,
    ...v
  } = n2, E = useThree((D) => D.camera), S = useThree((D) => D.gl), M = useThree((D) => D.invalidate), x = useThree((D) => D.events), O = useThree((D) => D.setEvents), A = useThree((D) => D.set), Q = useThree((D) => D.get), ht = useThree((D) => D.performance), _t = e || E, kt = i || x.connected || S.domElement, k = (0, import_react.useMemo)(() => new _e(_t), [_t]);
  return useFrame((D, At) => {
    k.enabled && k.update(At);
  }, -1), (0, import_react.useEffect)(() => (k.connect(kt), () => void k.disconnect()), [kt, k]), (0, import_react.useEffect)(() => {
    function D() {
      M(), d2 && ht.regress();
    }
    const At = (U) => {
      D(), r2 == null || r2(U), y == null || y(U);
    }, j = (U) => {
      D(), o2 == null || o2(U), b == null || b(U);
    }, Gt2 = (U) => {
      a == null || a(U), T == null || T(U);
    }, Kt = (U) => {
      D(), l2 == null || l2(U), b == null || b(U);
    }, Jt = (U) => {
      D(), c == null || c(U), b == null || b(U);
    }, ut = (U) => {
      D(), h == null || h(U), b == null || b(U);
    }, $ = (U) => {
      u == null || u(U);
    }, z = (U) => {
      p == null || p(U);
    };
    return k.addEventListener("controlstart", At), k.addEventListener("control", j), k.addEventListener("controlend", Gt2), k.addEventListener("transitionstart", Kt), k.addEventListener("update", Jt), k.addEventListener("wake", ut), k.addEventListener("rest", $), k.addEventListener("sleep", z), () => {
      k.removeEventListener("controlstart", At), k.removeEventListener("control", j), k.removeEventListener("controlend", Gt2), k.removeEventListener("transitionstart", Kt), k.removeEventListener("update", Jt), k.removeEventListener("wake", ut), k.removeEventListener("rest", $), k.removeEventListener("sleep", z);
    };
  }, [k, M, O, d2, ht, r2, o2, a, l2, c, h, u, p, b, y, T]), (0, import_react.useEffect)(() => {
    if (s2) {
      const D = Q().controls;
      return A({
        controls: k
      }), () => A({
        controls: D
      });
    }
  }, [s2, k]), I.createElement("primitive", ye({
    ref: t2,
    object: k
  }, v));
});
function Uo({
  defaultScene: n2,
  defaultCamera: t2,
  renderPriority: e = 1
}) {
  const {
    gl: i,
    scene: s2,
    camera: r2
  } = useThree();
  let o2;
  return useFrame(() => {
    o2 = i.autoClear, e === 1 && (i.autoClear = true, i.render(n2, t2)), i.autoClear = false, i.clearDepth(), i.render(s2, r2), i.autoClear = o2;
  }, e), I.createElement("group", {
    onPointerOver: () => null
  });
}
function Do2({
  children: n2,
  renderPriority: t2 = 1
}) {
  const {
    scene: e,
    camera: i
  } = useThree(), [s2] = I.useState(() => new Scene());
  return I.createElement(I.Fragment, null, createPortal(I.createElement(I.Fragment, null, n2, I.createElement(Uo, {
    defaultScene: e,
    defaultCamera: i,
    renderPriority: t2
  })), s2, {
    events: {
      priority: t2 + 1
    }
  }));
}
var ko2 = So(
  {
    cellSize: 0.5,
    sectionSize: 1,
    fadeDistance: 100,
    fadeStrength: 1,
    fadeFrom: 1,
    cellThickness: 0.5,
    sectionThickness: 1,
    cellColor: new Color(),
    sectionColor: new Color(),
    infiniteGrid: false,
    followCamera: false,
    worldCamProjPosition: new Vector3(),
    worldPlanePosition: new Vector3()
  },
  /* glsl */
  `
    varying vec3 localPosition;
    varying vec4 worldPosition;

    uniform vec3 worldCamProjPosition;
    uniform vec3 worldPlanePosition;
    uniform float fadeDistance;
    uniform bool infiniteGrid;
    uniform bool followCamera;

    void main() {
      localPosition = position.xzy;
      if (infiniteGrid) localPosition *= 1.0 + fadeDistance;
      
      worldPosition = modelMatrix * vec4(localPosition, 1.0);
      if (followCamera) {
        worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);
        localPosition = (inverse(modelMatrix) * worldPosition).xyz;
      }

      gl_Position = projectionMatrix * viewMatrix * worldPosition;
    }
  `,
  /* glsl */
  `
    varying vec3 localPosition;
    varying vec4 worldPosition;

    uniform vec3 worldCamProjPosition;
    uniform float cellSize;
    uniform float sectionSize;
    uniform vec3 cellColor;
    uniform vec3 sectionColor;
    uniform float fadeDistance;
    uniform float fadeStrength;
    uniform float fadeFrom;
    uniform float cellThickness;
    uniform float sectionThickness;

    float getGrid(float size, float thickness) {
      vec2 r = localPosition.xz / size;
      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
      float line = min(grid.x, grid.y) + 1.0 - thickness;
      return 1.0 - min(line, 1.0);
    }

    void main() {
      float g1 = getGrid(cellSize, cellThickness);
      float g2 = getGrid(sectionSize, sectionThickness);

      vec3 from = worldCamProjPosition*vec3(fadeFrom);
      float dist = distance(from, worldPosition.xyz);
      float d = 1.0 - min(dist / fadeDistance, 1.0);
      vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));

      gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));
      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
      if (gl_FragColor.a <= 0.0) discard;

      #include <tonemapping_fragment>
      #include <${Ao >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
    }
  `
);
var Fo = I.forwardRef(({
  args: n2,
  cellColor: t2 = "#000000",
  sectionColor: e = "#2080ff",
  cellSize: i = 0.5,
  sectionSize: s2 = 1,
  followCamera: r2 = false,
  infiniteGrid: o2 = false,
  fadeDistance: a = 100,
  fadeStrength: l2 = 1,
  fadeFrom: c = 1,
  cellThickness: h = 0.5,
  sectionThickness: u = 1,
  side: p = BackSide,
  ...y
}, T) => {
  extend({
    GridMaterial: ko2
  });
  const b = I.useRef(null);
  I.useImperativeHandle(T, () => b.current, []);
  const d2 = new Plane(), v = new Vector3(0, 1, 0), E = new Vector3(0, 0, 0);
  useFrame((x) => {
    d2.setFromNormalAndCoplanarPoint(v, E).applyMatrix4(b.current.matrixWorld);
    const O = b.current.material, A = O.uniforms.worldCamProjPosition, Q = O.uniforms.worldPlanePosition;
    d2.projectPoint(x.camera.position, A.value), Q.value.set(0, 0, 0).applyMatrix4(b.current.matrixWorld);
  });
  const S = {
    cellSize: i,
    sectionSize: s2,
    cellColor: t2,
    sectionColor: e,
    cellThickness: h,
    sectionThickness: u
  }, M = {
    fadeDistance: a,
    fadeStrength: l2,
    fadeFrom: c,
    infiniteGrid: o2,
    followCamera: r2
  };
  return I.createElement("mesh", ye({
    ref: b,
    frustumCulled: false
  }, y), I.createElement("gridMaterial", ye({
    transparent: true,
    "extensions-derivatives": true,
    side: p
  }, S, M)), I.createElement("planeGeometry", {
    args: n2
  }));
});
function Yo() {
  const n2 = ni(), [t2, e] = (0, import_react.useState)(true);
  return (0, import_react.useEffect)(() => F("extension-point-triggered", (s2) => {
    if (s2.scope === "scene" && s2.id === "toggle_grid")
      return e((r2) => !r2), { handled: true };
  }), []), (0, import_jsx_runtime.jsx)(
    Fo,
    {
      cellColor: "#6f6f6f",
      cellSize: 1,
      cellThickness: 1,
      fadeDistance: 100,
      fadeStrength: 5,
      followCamera: true,
      infiniteGrid: true,
      layers: n,
      position: [0, 0.01, 0],
      sectionColor: "#9d4b4b",
      sectionSize: 3,
      side: 2,
      visible: n2 !== "play" && t2
    }
  );
}
function Zo(n2) {
  const t2 = new Box3(), e = new Box3();
  return n2.forEach((i) => {
    i.layers.test(n) || i.type.includes("Helper") || (t2.setFromObject(i), !(t2.max.lengthSq() > 1e3) && e.union(t2));
  }), e.getBoundingSphere(new Sphere());
}
function br(n2) {
  if ("isInteractionPanel" in n2 || n2.name === "forced_visible")
    return true;
  if (!n2.visible)
    return false;
  let e = n2;
  for (; e; ) {
    if (!e.visible)
      return false;
    e = e.parent;
  }
  return true;
}
function No(n2) {
  const t2 = { ...n2.meta.props.current };
  for (const e in t2) {
    const i = t2[e];
    i && typeof i == "object" && "$$typeof" in i && delete t2[e];
  }
  if ("position" in t2) {
    const e = n2.object.getWorldPosition(new Vector3()).toArray();
    return {
      ...t2,
      position: e
    };
  }
  return t2;
}
function We(n2) {
  return +Number.parseFloat(Number(n2).toPrecision(15));
}
function jn(n2, t2, e = new Vector3(0, 0, 1), i = false) {
  const s2 = Zo(n2);
  if (s2.isEmpty() || /**
  * There are edge cases where a scene can return NaN for its radius. One
  * example is the uikit example in test-fixtures doing this on initial load.
  * To prevent the camera from getting into invalid states we check this and
  * abort early.
  */
  Number.isNaN(s2.radius))
    return;
  const r2 = new Spherical().setFromVector3(e);
  t2.rotateTo(r2.theta, r2.phi, i), t2.fitToSphere(s2, i);
}
function Yi(n2) {
  "@babel/helpers - typeof";
  return Yi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t2) {
    return typeof t2;
  } : function(t2) {
    return t2 && typeof Symbol == "function" && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
  }, Yi(n2);
}
var Xo = /^\s+/;
var Vo = /\s+$/;
function R(n2, t2) {
  if (n2 = n2 || "", t2 = t2 || {}, n2 instanceof R)
    return n2;
  if (!(this instanceof R))
    return new R(n2, t2);
  var e = Qo(n2);
  this._originalInput = n2, this._r = e.r, this._g = e.g, this._b = e.b, this._a = e.a, this._roundA = Math.round(100 * this._a) / 100, this._format = t2.format || e.format, this._gradientType = t2.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = e.ok;
}
R.prototype = {
  isDark: function() {
    return this.getBrightness() < 128;
  },
  isLight: function() {
    return !this.isDark();
  },
  isValid: function() {
    return this._ok;
  },
  getOriginalInput: function() {
    return this._originalInput;
  },
  getFormat: function() {
    return this._format;
  },
  getAlpha: function() {
    return this._a;
  },
  getBrightness: function() {
    var t2 = this.toRgb();
    return (t2.r * 299 + t2.g * 587 + t2.b * 114) / 1e3;
  },
  getLuminance: function() {
    var t2 = this.toRgb(), e, i, s2, r2, o2, a;
    return e = t2.r / 255, i = t2.g / 255, s2 = t2.b / 255, e <= 0.03928 ? r2 = e / 12.92 : r2 = Math.pow((e + 0.055) / 1.055, 2.4), i <= 0.03928 ? o2 = i / 12.92 : o2 = Math.pow((i + 0.055) / 1.055, 2.4), s2 <= 0.03928 ? a = s2 / 12.92 : a = Math.pow((s2 + 0.055) / 1.055, 2.4), 0.2126 * r2 + 0.7152 * o2 + 0.0722 * a;
  },
  setAlpha: function(t2) {
    return this._a = Er(t2), this._roundA = Math.round(100 * this._a) / 100, this;
  },
  toHsv: function() {
    var t2 = vs(this._r, this._g, this._b);
    return {
      h: t2.h * 360,
      s: t2.s,
      v: t2.v,
      a: this._a
    };
  },
  toHsvString: function() {
    var t2 = vs(this._r, this._g, this._b), e = Math.round(t2.h * 360), i = Math.round(t2.s * 100), s2 = Math.round(t2.v * 100);
    return this._a == 1 ? "hsv(" + e + ", " + i + "%, " + s2 + "%)" : "hsva(" + e + ", " + i + "%, " + s2 + "%, " + this._roundA + ")";
  },
  toHsl: function() {
    var t2 = ys(this._r, this._g, this._b);
    return {
      h: t2.h * 360,
      s: t2.s,
      l: t2.l,
      a: this._a
    };
  },
  toHslString: function() {
    var t2 = ys(this._r, this._g, this._b), e = Math.round(t2.h * 360), i = Math.round(t2.s * 100), s2 = Math.round(t2.l * 100);
    return this._a == 1 ? "hsl(" + e + ", " + i + "%, " + s2 + "%)" : "hsla(" + e + ", " + i + "%, " + s2 + "%, " + this._roundA + ")";
  },
  toHex: function(t2) {
    return ws(this._r, this._g, this._b, t2);
  },
  toHexString: function(t2) {
    return "#" + this.toHex(t2);
  },
  toHex8: function(t2) {
    return Bo(this._r, this._g, this._b, this._a, t2);
  },
  toHex8String: function(t2) {
    return "#" + this.toHex8(t2);
  },
  toRgb: function() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function() {
    return {
      r: Math.round(B(this._r, 255) * 100) + "%",
      g: Math.round(B(this._g, 255) * 100) + "%",
      b: Math.round(B(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(B(this._r, 255) * 100) + "%, " + Math.round(B(this._g, 255) * 100) + "%, " + Math.round(B(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(B(this._r, 255) * 100) + "%, " + Math.round(B(this._g, 255) * 100) + "%, " + Math.round(B(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function() {
    return this._a === 0 ? "transparent" : this._a < 1 ? false : aa[ws(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function(t2) {
    var e = "#" + xs(this._r, this._g, this._b, this._a), i = e, s2 = this._gradientType ? "GradientType = 1, " : "";
    if (t2) {
      var r2 = R(t2);
      i = "#" + xs(r2._r, r2._g, r2._b, r2._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + s2 + "startColorstr=" + e + ",endColorstr=" + i + ")";
  },
  toString: function(t2) {
    var e = !!t2;
    t2 = t2 || this._format;
    var i = false, s2 = this._a < 1 && this._a >= 0, r2 = !e && s2 && (t2 === "hex" || t2 === "hex6" || t2 === "hex3" || t2 === "hex4" || t2 === "hex8" || t2 === "name");
    return r2 ? t2 === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (t2 === "rgb" && (i = this.toRgbString()), t2 === "prgb" && (i = this.toPercentageRgbString()), (t2 === "hex" || t2 === "hex6") && (i = this.toHexString()), t2 === "hex3" && (i = this.toHexString(true)), t2 === "hex4" && (i = this.toHex8String(true)), t2 === "hex8" && (i = this.toHex8String()), t2 === "name" && (i = this.toName()), t2 === "hsl" && (i = this.toHslString()), t2 === "hsv" && (i = this.toHsvString()), i || this.toHexString());
  },
  clone: function() {
    return R(this.toString());
  },
  _applyModification: function(t2, e) {
    var i = t2.apply(null, [this].concat([].slice.call(e)));
    return this._r = i._r, this._g = i._g, this._b = i._b, this.setAlpha(i._a), this;
  },
  lighten: function() {
    return this._applyModification(Jo, arguments);
  },
  brighten: function() {
    return this._applyModification(ta, arguments);
  },
  darken: function() {
    return this._applyModification(ea, arguments);
  },
  desaturate: function() {
    return this._applyModification($o2, arguments);
  },
  saturate: function() {
    return this._applyModification(Go2, arguments);
  },
  greyscale: function() {
    return this._applyModification(Ko, arguments);
  },
  spin: function() {
    return this._applyModification(ia, arguments);
  },
  _applyCombination: function(t2, e) {
    return t2.apply(null, [this].concat([].slice.call(e)));
  },
  analogous: function() {
    return this._applyCombination(ra, arguments);
  },
  complement: function() {
    return this._applyCombination(na, arguments);
  },
  monochromatic: function() {
    return this._applyCombination(oa, arguments);
  },
  splitcomplement: function() {
    return this._applyCombination(sa, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function() {
    return this._applyCombination(bs, [3]);
  },
  tetrad: function() {
    return this._applyCombination(bs, [4]);
  }
};
R.fromRatio = function(n2, t2) {
  if (Yi(n2) == "object") {
    var e = {};
    for (var i in n2)
      n2.hasOwnProperty(i) && (i === "a" ? e[i] = n2[i] : e[i] = fi(n2[i]));
    n2 = e;
  }
  return R(n2, t2);
};
function Qo(n2) {
  var t2 = {
    r: 0,
    g: 0,
    b: 0
  }, e = 1, i = null, s2 = null, r2 = null, o2 = false, a = false;
  return typeof n2 == "string" && (n2 = ua(n2)), Yi(n2) == "object" && (Qt(n2.r) && Qt(n2.g) && Qt(n2.b) ? (t2 = jo(n2.r, n2.g, n2.b), o2 = true, a = String(n2.r).substr(-1) === "%" ? "prgb" : "rgb") : Qt(n2.h) && Qt(n2.s) && Qt(n2.v) ? (i = fi(n2.s), s2 = fi(n2.v), t2 = qo(n2.h, i, s2), o2 = true, a = "hsv") : Qt(n2.h) && Qt(n2.s) && Qt(n2.l) && (i = fi(n2.s), r2 = fi(n2.l), t2 = Wo(n2.h, i, r2), o2 = true, a = "hsl"), n2.hasOwnProperty("a") && (e = n2.a)), e = Er(e), {
    ok: o2,
    format: n2.format || a,
    r: Math.min(255, Math.max(t2.r, 0)),
    g: Math.min(255, Math.max(t2.g, 0)),
    b: Math.min(255, Math.max(t2.b, 0)),
    a: e
  };
}
function jo(n2, t2, e) {
  return {
    r: B(n2, 255) * 255,
    g: B(t2, 255) * 255,
    b: B(e, 255) * 255
  };
}
function ys(n2, t2, e) {
  n2 = B(n2, 255), t2 = B(t2, 255), e = B(e, 255);
  var i = Math.max(n2, t2, e), s2 = Math.min(n2, t2, e), r2, o2, a = (i + s2) / 2;
  if (i == s2)
    r2 = o2 = 0;
  else {
    var l2 = i - s2;
    switch (o2 = a > 0.5 ? l2 / (2 - i - s2) : l2 / (i + s2), i) {
      case n2:
        r2 = (t2 - e) / l2 + (t2 < e ? 6 : 0);
        break;
      case t2:
        r2 = (e - n2) / l2 + 2;
        break;
      case e:
        r2 = (n2 - t2) / l2 + 4;
        break;
    }
    r2 /= 6;
  }
  return {
    h: r2,
    s: o2,
    l: a
  };
}
function Wo(n2, t2, e) {
  var i, s2, r2;
  n2 = B(n2, 360), t2 = B(t2, 100), e = B(e, 100);
  function o2(c, h, u) {
    return u < 0 && (u += 1), u > 1 && (u -= 1), u < 1 / 6 ? c + (h - c) * 6 * u : u < 1 / 2 ? h : u < 2 / 3 ? c + (h - c) * (2 / 3 - u) * 6 : c;
  }
  if (t2 === 0)
    i = s2 = r2 = e;
  else {
    var a = e < 0.5 ? e * (1 + t2) : e + t2 - e * t2, l2 = 2 * e - a;
    i = o2(l2, a, n2 + 1 / 3), s2 = o2(l2, a, n2), r2 = o2(l2, a, n2 - 1 / 3);
  }
  return {
    r: i * 255,
    g: s2 * 255,
    b: r2 * 255
  };
}
function vs(n2, t2, e) {
  n2 = B(n2, 255), t2 = B(t2, 255), e = B(e, 255);
  var i = Math.max(n2, t2, e), s2 = Math.min(n2, t2, e), r2, o2, a = i, l2 = i - s2;
  if (o2 = i === 0 ? 0 : l2 / i, i == s2)
    r2 = 0;
  else {
    switch (i) {
      case n2:
        r2 = (t2 - e) / l2 + (t2 < e ? 6 : 0);
        break;
      case t2:
        r2 = (e - n2) / l2 + 2;
        break;
      case e:
        r2 = (n2 - t2) / l2 + 4;
        break;
    }
    r2 /= 6;
  }
  return {
    h: r2,
    s: o2,
    v: a
  };
}
function qo(n2, t2, e) {
  n2 = B(n2, 360) * 6, t2 = B(t2, 100), e = B(e, 100);
  var i = Math.floor(n2), s2 = n2 - i, r2 = e * (1 - t2), o2 = e * (1 - s2 * t2), a = e * (1 - (1 - s2) * t2), l2 = i % 6, c = [e, o2, r2, r2, a, e][l2], h = [a, e, e, o2, r2, r2][l2], u = [r2, r2, a, e, e, o2][l2];
  return {
    r: c * 255,
    g: h * 255,
    b: u * 255
  };
}
function ws(n2, t2, e, i) {
  var s2 = [It(Math.round(n2).toString(16)), It(Math.round(t2).toString(16)), It(Math.round(e).toString(16))];
  return i && s2[0].charAt(0) == s2[0].charAt(1) && s2[1].charAt(0) == s2[1].charAt(1) && s2[2].charAt(0) == s2[2].charAt(1) ? s2[0].charAt(0) + s2[1].charAt(0) + s2[2].charAt(0) : s2.join("");
}
function Bo(n2, t2, e, i, s2) {
  var r2 = [It(Math.round(n2).toString(16)), It(Math.round(t2).toString(16)), It(Math.round(e).toString(16)), It(Tr(i))];
  return s2 && r2[0].charAt(0) == r2[0].charAt(1) && r2[1].charAt(0) == r2[1].charAt(1) && r2[2].charAt(0) == r2[2].charAt(1) && r2[3].charAt(0) == r2[3].charAt(1) ? r2[0].charAt(0) + r2[1].charAt(0) + r2[2].charAt(0) + r2[3].charAt(0) : r2.join("");
}
function xs(n2, t2, e, i) {
  var s2 = [It(Tr(i)), It(Math.round(n2).toString(16)), It(Math.round(t2).toString(16)), It(Math.round(e).toString(16))];
  return s2.join("");
}
R.equals = function(n2, t2) {
  return !n2 || !t2 ? false : R(n2).toRgbString() == R(t2).toRgbString();
};
R.random = function() {
  return R.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function $o2(n2, t2) {
  t2 = t2 === 0 ? 0 : t2 || 10;
  var e = R(n2).toHsl();
  return e.s -= t2 / 100, e.s = qi(e.s), R(e);
}
function Go2(n2, t2) {
  t2 = t2 === 0 ? 0 : t2 || 10;
  var e = R(n2).toHsl();
  return e.s += t2 / 100, e.s = qi(e.s), R(e);
}
function Ko(n2) {
  return R(n2).desaturate(100);
}
function Jo(n2, t2) {
  t2 = t2 === 0 ? 0 : t2 || 10;
  var e = R(n2).toHsl();
  return e.l += t2 / 100, e.l = qi(e.l), R(e);
}
function ta(n2, t2) {
  t2 = t2 === 0 ? 0 : t2 || 10;
  var e = R(n2).toRgb();
  return e.r = Math.max(0, Math.min(255, e.r - Math.round(255 * -(t2 / 100)))), e.g = Math.max(0, Math.min(255, e.g - Math.round(255 * -(t2 / 100)))), e.b = Math.max(0, Math.min(255, e.b - Math.round(255 * -(t2 / 100)))), R(e);
}
function ea(n2, t2) {
  t2 = t2 === 0 ? 0 : t2 || 10;
  var e = R(n2).toHsl();
  return e.l -= t2 / 100, e.l = qi(e.l), R(e);
}
function ia(n2, t2) {
  var e = R(n2).toHsl(), i = (e.h + t2) % 360;
  return e.h = i < 0 ? 360 + i : i, R(e);
}
function na(n2) {
  var t2 = R(n2).toHsl();
  return t2.h = (t2.h + 180) % 360, R(t2);
}
function bs(n2, t2) {
  if (isNaN(t2) || t2 <= 0)
    throw new Error("Argument to polyad must be a positive number");
  for (var e = R(n2).toHsl(), i = [R(n2)], s2 = 360 / t2, r2 = 1; r2 < t2; r2++)
    i.push(R({
      h: (e.h + r2 * s2) % 360,
      s: e.s,
      l: e.l
    }));
  return i;
}
function sa(n2) {
  var t2 = R(n2).toHsl(), e = t2.h;
  return [R(n2), R({
    h: (e + 72) % 360,
    s: t2.s,
    l: t2.l
  }), R({
    h: (e + 216) % 360,
    s: t2.s,
    l: t2.l
  })];
}
function ra(n2, t2, e) {
  t2 = t2 || 6, e = e || 30;
  var i = R(n2).toHsl(), s2 = 360 / e, r2 = [R(n2)];
  for (i.h = (i.h - (s2 * t2 >> 1) + 720) % 360; --t2; )
    i.h = (i.h + s2) % 360, r2.push(R(i));
  return r2;
}
function oa(n2, t2) {
  t2 = t2 || 6;
  for (var e = R(n2).toHsv(), i = e.h, s2 = e.s, r2 = e.v, o2 = [], a = 1 / t2; t2--; )
    o2.push(R({
      h: i,
      s: s2,
      v: r2
    })), r2 = (r2 + a) % 1;
  return o2;
}
R.mix = function(n2, t2, e) {
  e = e === 0 ? 0 : e || 50;
  var i = R(n2).toRgb(), s2 = R(t2).toRgb(), r2 = e / 100, o2 = {
    r: (s2.r - i.r) * r2 + i.r,
    g: (s2.g - i.g) * r2 + i.g,
    b: (s2.b - i.b) * r2 + i.b,
    a: (s2.a - i.a) * r2 + i.a
  };
  return R(o2);
};
R.readability = function(n2, t2) {
  var e = R(n2), i = R(t2);
  return (Math.max(e.getLuminance(), i.getLuminance()) + 0.05) / (Math.min(e.getLuminance(), i.getLuminance()) + 0.05);
};
R.isReadable = function(n2, t2, e) {
  var i = R.readability(n2, t2), s2, r2;
  switch (r2 = false, s2 = da(e), s2.level + s2.size) {
    case "AAsmall":
    case "AAAlarge":
      r2 = i >= 4.5;
      break;
    case "AAlarge":
      r2 = i >= 3;
      break;
    case "AAAsmall":
      r2 = i >= 7;
      break;
  }
  return r2;
};
R.mostReadable = function(n2, t2, e) {
  var i = null, s2 = 0, r2, o2, a, l2;
  e = e || {}, o2 = e.includeFallbackColors, a = e.level, l2 = e.size;
  for (var c = 0; c < t2.length; c++)
    r2 = R.readability(n2, t2[c]), r2 > s2 && (s2 = r2, i = R(t2[c]));
  return R.isReadable(n2, i, {
    level: a,
    size: l2
  }) || !o2 ? i : (e.includeFallbackColors = false, R.mostReadable(n2, ["#fff", "#000"], e));
};
var In = R.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var aa = R.hexNames = la(In);
function la(n2) {
  var t2 = {};
  for (var e in n2)
    n2.hasOwnProperty(e) && (t2[n2[e]] = e);
  return t2;
}
function Er(n2) {
  return n2 = parseFloat(n2), (isNaN(n2) || n2 < 0 || n2 > 1) && (n2 = 1), n2;
}
function B(n2, t2) {
  ca(n2) && (n2 = "100%");
  var e = ha(n2);
  return n2 = Math.min(t2, Math.max(0, parseFloat(n2))), e && (n2 = parseInt(n2 * t2, 10) / 100), Math.abs(n2 - t2) < 1e-6 ? 1 : n2 % t2 / parseFloat(t2);
}
function qi(n2) {
  return Math.min(1, Math.max(0, n2));
}
function wt(n2) {
  return parseInt(n2, 16);
}
function ca(n2) {
  return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
}
function ha(n2) {
  return typeof n2 == "string" && n2.indexOf("%") != -1;
}
function It(n2) {
  return n2.length == 1 ? "0" + n2 : "" + n2;
}
function fi(n2) {
  return n2 <= 1 && (n2 = n2 * 100 + "%"), n2;
}
function Tr(n2) {
  return Math.round(parseFloat(n2) * 255).toString(16);
}
function Es2(n2) {
  return wt(n2) / 255;
}
var Ht = function() {
  var n2 = "[-\\+]?\\d+%?", t2 = "[-\\+]?\\d*\\.\\d+%?", e = "(?:" + t2 + ")|(?:" + n2 + ")", i = "[\\s|\\(]+(" + e + ")[,|\\s]+(" + e + ")[,|\\s]+(" + e + ")\\s*\\)?", s2 = "[\\s|\\(]+(" + e + ")[,|\\s]+(" + e + ")[,|\\s]+(" + e + ")[,|\\s]+(" + e + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(e),
    rgb: new RegExp("rgb" + i),
    rgba: new RegExp("rgba" + s2),
    hsl: new RegExp("hsl" + i),
    hsla: new RegExp("hsla" + s2),
    hsv: new RegExp("hsv" + i),
    hsva: new RegExp("hsva" + s2),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function Qt(n2) {
  return !!Ht.CSS_UNIT.exec(n2);
}
function ua(n2) {
  n2 = n2.replace(Xo, "").replace(Vo, "").toLowerCase();
  var t2 = false;
  if (In[n2])
    n2 = In[n2], t2 = true;
  else if (n2 == "transparent")
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  var e;
  return (e = Ht.rgb.exec(n2)) ? {
    r: e[1],
    g: e[2],
    b: e[3]
  } : (e = Ht.rgba.exec(n2)) ? {
    r: e[1],
    g: e[2],
    b: e[3],
    a: e[4]
  } : (e = Ht.hsl.exec(n2)) ? {
    h: e[1],
    s: e[2],
    l: e[3]
  } : (e = Ht.hsla.exec(n2)) ? {
    h: e[1],
    s: e[2],
    l: e[3],
    a: e[4]
  } : (e = Ht.hsv.exec(n2)) ? {
    h: e[1],
    s: e[2],
    v: e[3]
  } : (e = Ht.hsva.exec(n2)) ? {
    h: e[1],
    s: e[2],
    v: e[3],
    a: e[4]
  } : (e = Ht.hex8.exec(n2)) ? {
    r: wt(e[1]),
    g: wt(e[2]),
    b: wt(e[3]),
    a: Es2(e[4]),
    format: t2 ? "name" : "hex8"
  } : (e = Ht.hex6.exec(n2)) ? {
    r: wt(e[1]),
    g: wt(e[2]),
    b: wt(e[3]),
    format: t2 ? "name" : "hex"
  } : (e = Ht.hex4.exec(n2)) ? {
    r: wt(e[1] + "" + e[1]),
    g: wt(e[2] + "" + e[2]),
    b: wt(e[3] + "" + e[3]),
    a: Es2(e[4] + "" + e[4]),
    format: t2 ? "name" : "hex8"
  } : (e = Ht.hex3.exec(n2)) ? {
    r: wt(e[1] + "" + e[1]),
    g: wt(e[2] + "" + e[2]),
    b: wt(e[3] + "" + e[3]),
    format: t2 ? "name" : "hex"
  } : false;
}
function da(n2) {
  var t2, e;
  return n2 = n2 || {
    level: "AA",
    size: "small"
  }, t2 = (n2.level || "AA").toUpperCase(), e = (n2.size || "small").toLowerCase(), t2 !== "AA" && t2 !== "AAA" && (t2 = "AA"), e !== "small" && e !== "large" && (e = "small"), {
    level: t2,
    size: e
  };
}
function on2({
  color: n2,
  rotation: t2,
  spriteSize: e
}) {
  const i = 1 - e / 2, s2 = 0.05;
  return (0, import_jsx_runtime.jsx)("group", { rotation: t2, children: (0, import_jsx_runtime.jsxs)("mesh", { position: [i / 2, 0, 0], children: [
    (0, import_jsx_runtime.jsx)("boxGeometry", { args: [i, s2, s2] }),
    (0, import_jsx_runtime.jsx)("meshBasicMaterial", { color: n2, toneMapped: false })
  ] }) });
}
function Te({
  color: n2,
  font: t2,
  label: e,
  labelColor: i,
  onClick: s2,
  position: r2,
  size: o2
}) {
  const [a, l2] = (0, import_react.useState)(false), c = e ? o2 : o2 - 0.15, h = (0, import_react.useMemo)(() => {
    const u = document.createElement("canvas"), p = 128, y = p / 16;
    u.width = p, u.height = p;
    const T = u.getContext("2d");
    return T.beginPath(), T.arc(p / 2, p / 2, p / 2 - y / 2, 0, 2 * Math.PI), T.closePath(), T.strokeStyle = n2, T.lineWidth = y, e ? (T.fillStyle = R(n2).lighten(5).toHexString(), T.fill(), T.font = `${p / 2}px ${t2}`, T.textAlign = "center", T.textBaseline = "middle", T.fillStyle = i, T.textRendering = "optimizeSpeed", T.fillText(e, p / 2, p / 2 + 2)) : (T.fillStyle = R(n2).lighten(20).toHexString(), T.fill()), T.stroke(), new CanvasTexture(u);
  }, [e, n2, t2, i]);
  return (0, import_jsx_runtime.jsx)(
    "sprite",
    {
      onClick: s2,
      onPointerOut: () => l2(false),
      onPointerOver: () => l2(true),
      position: r2,
      scale: c,
      children: (0, import_jsx_runtime.jsx)(
        "spriteMaterial",
        {
          alphaTest: 0.5,
          map: h,
          opacity: a ? 1 : 0.8,
          toneMapped: false
        }
      )
    }
  );
}
function fa() {
  const [n2, t2] = (0, import_react.useState)(false);
  return (0, import_jsx_runtime.jsxs)(
    "mesh",
    {
      onPointerOut: () => t2(false),
      onPointerOver: () => t2(true),
      children: [
        (0, import_jsx_runtime.jsx)(
          "sphereGeometry",
          {
            args: [1.5, 48, 24],
            ref: (e) => {
              if (!e || !e.index || "inverted" in e)
                return;
              const i = e.index.array;
              for (let s2 = 0, r2 = i.length / 3; s2 < r2; s2++) {
                let o2 = i[s2 * 3];
                i[s2 * 3] = i[s2 * 3 + 2], i[s2 * 3 + 2] = o2;
              }
              e.index.needsUpdate = true, Object.assign(e, { inverted: true });
            }
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "meshBasicMaterial",
          {
            color: "#fff",
            opacity: n2 ? 0.2 : 0.1,
            toneMapped: false,
            transparent: true
          }
        )
      ]
    }
  );
}
function pa({
  colors: {
    axis: n2 = { x: "#ff2060", y: "#20df80", z: "#2080ff" },
    text: t2 = "#000"
  } = {},
  font: e = "sans-serif",
  onClick: i,
  scale: s2
}) {
  return (0, import_jsx_runtime.jsxs)("group", { scale: s2, children: [
    (0, import_jsx_runtime.jsx)(fa, {}),
    (0, import_jsx_runtime.jsx)(on2, { color: n2.x, rotation: [0, 0, 0], spriteSize: 0.6 }),
    (0, import_jsx_runtime.jsx)(
      on2,
      {
        color: n2.y,
        rotation: [0, 0, Math.PI / 2],
        spriteSize: 0.6
      }
    ),
    (0, import_jsx_runtime.jsx)(
      on2,
      {
        color: n2.z,
        rotation: [0, -Math.PI / 2, 0],
        spriteSize: 0.6
      }
    ),
    (0, import_jsx_runtime.jsx)(
      Te,
      {
        color: n2.x,
        font: e,
        label: "X",
        labelColor: t2,
        onClick: i,
        position: [1, 0, 0],
        size: 0.6
      }
    ),
    (0, import_jsx_runtime.jsx)(
      Te,
      {
        color: n2.y,
        font: e,
        label: "Y",
        labelColor: t2,
        onClick: i,
        position: [0, 1, 0],
        size: 0.6
      }
    ),
    (0, import_jsx_runtime.jsx)(
      Te,
      {
        color: n2.z,
        font: e,
        label: "Z",
        labelColor: t2,
        onClick: i,
        position: [0, 0, 1],
        size: 0.6
      }
    ),
    (0, import_jsx_runtime.jsx)(
      Te,
      {
        color: n2.x,
        font: e,
        labelColor: t2,
        onClick: i,
        position: [-1, 0, 0],
        size: 0.6
      }
    ),
    (0, import_jsx_runtime.jsx)(
      Te,
      {
        color: n2.y,
        font: e,
        labelColor: t2,
        onClick: i,
        position: [0, -1, 0],
        size: 0.6
      }
    ),
    (0, import_jsx_runtime.jsx)(
      Te,
      {
        color: n2.z,
        font: e,
        labelColor: t2,
        onClick: i,
        position: [0, 0, -1],
        size: 0.6
      }
    )
  ] });
}
var Ts = new Matrix4();
var ma = ({
  alignment: n2 = "bottom-right",
  children: t2,
  margin: e = [80, 80],
  renderPriority: i = 1
}) => {
  const s2 = useThree((p) => p.size), r2 = (0, import_react.useContext)(vo), o2 = (0, import_react.useRef)(null), a = (0, import_react.useRef)(null);
  useFrame(() => {
    r2 && o2.current && (Ts.copy(r2.camera.matrix).invert(), o2.current.quaternion.setFromRotationMatrix(Ts));
  });
  const [l2, c] = e, h = n2.endsWith("-center") ? 0 : n2.endsWith("-left") ? -s2.width / 2 + l2 : s2.width / 2 - l2, u = n2.startsWith("center-") ? 0 : n2.startsWith("top-") ? s2.height / 2 - c : -s2.height / 2 + c;
  return (0, import_jsx_runtime.jsxs)(Do2, { renderPriority: i, children: [
    (0, import_jsx_runtime.jsx)(Ro2, { makeDefault: true, position: [0, 0, 200], ref: a }),
    (0, import_jsx_runtime.jsx)("group", { position: [h, u, 0], ref: o2, children: t2 })
  ] });
};
var Os2 = (n2, t2, e) => {
  jn(
    t2.children,
    n2,
    new Vector3(e.x, e.y, e.z),
    true
  );
};
function ga() {
  const n2 = (0, import_react.useContext)(vo), t2 = (0, import_react.useContext)(Es), e = useThree((i) => i.scene);
  return !n2 || n2.type === "default" ? null : (0, import_jsx_runtime.jsx)(ma, { alignment: "bottom-center", margin: [60, 60], renderPriority: 2, children: (0, import_jsx_runtime.jsx)(
    pa,
    {
      onClick: (i) => {
        t2 && (i.eventObject.position.x === 0 && i.eventObject.position.y === 0 && i.eventObject.position.z === 0 ? Os2(t2, e, i.face.normal) : Os2(t2, e, i.eventObject.position), N("track", { actionId: "controls_axishelper" }));
      },
      scale: 33
    }
  ) });
}
function _a({ resetKeys: n2 }) {
  const t2 = (0, import_react.useContext)(Es), e = useThree((o2) => o2.scene), i = (0, import_react.useRef)(false), s2 = n2 == null ? void 0 : n2.join(""), r2 = (0, import_react.useRef)(s2);
  return (0, import_react.useLayoutEffect)(() => {
    r2.current !== s2 && (r2.current = s2, i.current = false);
  }, [s2]), (0, import_react.useLayoutEffect)(() => {
    !t2 || i.current && ur("fit_to_camera_fix") || (jn(e.children, t2), i.current = true);
  }, [t2, e, s2]), null;
}
var an = {
  ctrl: {},
  rest: {
    left: _e.ACTION.ROTATE,
    middle: _e.ACTION.DOLLY,
    right: _e.ACTION.TRUCK
  },
  shift: {
    left: _e.ACTION.TRUCK
  }
};
var ln = {
  ctrl: {},
  rest: {},
  shift: {}
};
function Oe2(n2, t2) {
  const e = t2;
  for (const i in t2)
    n2[i] = e[i];
}
function ya({ children: n2 }) {
  const t2 = (0, import_react.useContext)(vo), [e, i] = (0, import_react.useState)(null), [s2, r2] = (0, import_react.useState)(
    "Rest"
  );
  return (0, import_react.useEffect)(() => {
    if (e)
      switch (s2) {
        case "Control":
          Oe2(e.touches, ln.ctrl), Oe2(e.mouseButtons, an.ctrl);
          break;
        case "Shift":
          Oe2(e.touches, ln.shift), Oe2(e.mouseButtons, an.shift);
          break;
        default:
          Oe2(e.touches, ln.rest), Oe2(e.mouseButtons, an.rest);
          break;
      }
  }, [s2, e]), (0, import_react.useEffect)(() => {
    let o2;
    return on.bindAll(window, [
      {
        listener: (a) => {
          if (a.key !== "Shift" && a.key !== "Control") {
            r2("Rest");
            return;
          }
          function l2() {
            document.hasFocus() && (window.clearInterval(o2), o2 = window.setInterval(() => {
              document.hasFocus() || (window.clearInterval(o2), r2("Rest"));
            }, 200));
          }
          switch (a.key) {
            case "Shift":
            case "Control":
              l2(), r2(a.key);
              break;
          }
        },
        options: { capture: true },
        type: "keydown"
      },
      {
        listener: (a) => {
          switch (a.key) {
            case "Shift":
            case "Control":
              window.clearInterval(o2), r2("Rest");
              break;
          }
        },
        options: { capture: true },
        type: "keyup"
      },
      {
        listener: () => {
          document.visibilityState === "hidden" && (window.clearInterval(o2), r2("Rest"));
        },
        type: "visibilitychange"
      }
    ]);
  }, []), (0, import_jsx_runtime.jsxs)(Es.Provider, { value: e, children: [
    n2,
    (t2 == null ? void 0 : t2.type) === "editor" && (0, import_jsx_runtime.jsx)(
      Io,
      {
        camera: t2.camera,
        ref: i
      }
    )
  ] });
}
var Zi = /* @__PURE__ */ new Map();
function va(n2, t2, e) {
  const i = `reducer-${e}`, s2 = Zi.get(i) || t2, [r2, o2] = (0, import_react.useReducer)(n2, s2);
  return (0, import_react.useEffect)(() => {
    Zi.set(i, r2);
  }, [i, r2]), [r2, o2];
}
function Or(n2, t2) {
  const e = `state-${t2}`, i = Zi.get(e) || n2, [s2, r2] = (0, import_react.useState)(i);
  return (0, import_react.useEffect)(() => {
    Zi.set(e, s2);
  }, [e, s2]), [s2, r2];
}
function wa(n2, t2) {
  function e() {
    const s2 = {
      height: n2.domElement.clientHeight,
      width: n2.domElement.clientWidth
    };
    t2.forEach((r2) => {
      if ("isOrthographicCamera" in r2) {
        const o2 = s2.width / -2, a = s2.width / 2, l2 = s2.height / 2, c = s2.height / -2;
        r2.left = o2, r2.right = a, r2.top = l2, r2.bottom = c, r2.updateProjectionMatrix();
      } else
        r2.aspect = s2.width / s2.height, r2.updateProjectionMatrix();
    });
  }
  const i = new ResizeObserver(e);
  return i.observe(n2.domElement), () => {
    i.disconnect();
  };
}
function xa({ children: n2 }) {
  const t2 = (0, import_react.useContext)(ho), [e, i] = Or(
    false,
    "editor-default"
  ), s2 = useThree((E) => E.camera), r2 = useThree((E) => E.gl), o2 = useThree((E) => E.set), a = (0, import_react.useRef)(s2), [l2, c] = (0, import_react.useState)(), [h, u] = (0, import_react.useState)(), p = ni(), [y, T] = va(
    (E, S) => S.action === "set-canvas-camera" ? p === "edit" ? { ...E, edit: S.camera } : { ...E, play: S.camera } : S.action === "set-editor-camera-type" ? { ...E, editor: S.type } : E,
    { edit: t2, editor: "perspective", play: "default" },
    "camera-state"
  ), b = p === "edit" ? y.edit : y.play, d2 = b === "default" ? s2 : y.editor === "perspective" ? l2 : h;
  (0, import_react.useEffect)(() => {
    s2 !== h && s2 !== l2 && (a.current = s2);
  }, [s2, h, l2]), (0, import_react.useLayoutEffect)(() => {
    if (!(!l2 || !h))
      return wa(r2, [s2, l2, h]);
  }, [s2, r2, h, l2]), (0, import_react.useEffect)(() => {
    if (e && d2 && b === "editor")
      return o2({
        camera: d2
      }), () => {
        o2({ camera: a.current });
      };
  }, [o2, e, d2, b]), (0, import_react.useEffect)(() => F("extension-point-triggered", ({ id: E, scope: S }) => {
    if (S === "scene")
      switch (E) {
        case "camera_editor_toggle_default":
          i((M) => !M);
          break;
        case "camera_editor":
          T({ action: "set-canvas-camera", camera: "editor" });
          break;
        case "camera_default":
          T({ action: "set-canvas-camera", camera: "default" });
          break;
        case "perspective":
        case "orthographic":
          return T({ action: "set-editor-camera-type", type: E }), { handled: true };
      }
  }), [s2, i]), (0, import_react.useEffect)(() => {
    if (d2)
      switch (p) {
        case "edit":
        case "pause":
          d2.layers.enable(s), d2.layers.enable(t);
          break;
        case "play":
          d2.layers.disable(s), d2.layers.disable(t);
          break;
      }
  }, [d2, p]), (0, import_react.useLayoutEffect)(() => {
    if (!d2 || b !== "editor")
      return;
    const E = r2.render;
    return r2.render = function(M, x, ...O) {
      return x === s2 && O.at(0) !== "triplex_ignore" ? E.call(this, M, d2, ...O) : E.call(this, M, x, ...O);
    }, () => {
      r2.render = E;
    };
  }, [r2, d2, b, s2]), useFrame(
    ({ gl: E, scene: S }) => {
      d2 && (E.autoClear = true, E.render(S, d2));
    },
    b === "editor" ? (
      // When the "editor" camera is active we use 0.5 so the callback runs before postprocessing.
      // See: https://github.com/pmndrs/react-postprocessing/blob/master/src/EffectComposer.tsx#L63
      0.5
    ) : (
      // When the "default" camera is active we release rendering back to defaults.
      void 0
    )
  );
  const v = (0, import_react.useMemo)(
    () => d2 ? { camera: d2, type: b } : null,
    [d2, b]
  );
  return (0, import_jsx_runtime.jsxs)(vo.Provider, { value: v, children: [
    n2,
    (0, import_jsx_runtime.jsx)(
      "perspectiveCamera",
      {
        far: 1e5,
        manual: true,
        name: "triplex_perspective",
        near: 0.01,
        position: [0, 0, 1],
        ref: c
      }
    ),
    (0, import_jsx_runtime.jsx)(
      "orthographicCamera",
      {
        far: 1e5,
        manual: true,
        name: "triplex_orthographic",
        near: -100,
        position: [0, 0, 1],
        ref: u,
        zoom: 100
      }
    )
  ] });
}
function ba({ children: n2 }) {
  return (0, import_jsx_runtime.jsx)(xa, { children: (0, import_jsx_runtime.jsxs)(ya, { children: [
    n2,
    false
  ] }) });
}
function Ea() {
  const { onSceneObjectCommitted: n2 } = Ro(), t2 = (0, import_react.useContext)(rn);
  return (0, import_react.useEffect)(() => {
    t2 > 0 && n2();
  }, [n2, t2]), null;
}
var Ps = `varying vec2 v_uv;
uniform sampler2D u_texture;

void main() {
  gl_FragColor = texture2D(u_texture, v_uv);
  #include <tonemapping_fragment>
  #include <colorspace_fragment>
}`;
var Ss = `varying vec2 v_uv;

float PREVIEW_SIZE = 0.33;
float DEFAULT_Z_POS = 0.5;

void main() {
  v_uv = uv;
  vec3 offset = vec3(
    -DEFAULT_Z_POS / PREVIEW_SIZE + DEFAULT_Z_POS,
    -DEFAULT_Z_POS / PREVIEW_SIZE + DEFAULT_Z_POS,
    0.0
  );
  gl_Position = vec4(position + offset, DEFAULT_Z_POS / PREVIEW_SIZE);
}`;
function Ta({ camera: n2 }) {
  const t2 = Fi(), e = useThree((i) => i.scene);
  return useFrame((i) => {
    i.gl.setRenderTarget(t2), i.gl.render(
      i.scene,
      n2,
      // @ts-expect-error — This is crammed in as an extra argument so we can check it
      // in {@link ../camera-new/cameras.tsx} and ensure we don't override the camera.
      "triplex_ignore"
    ), i.gl.setRenderTarget(null);
  }), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    false,
    createPortal(
      (0, import_jsx_runtime.jsxs)("mesh", { frustumCulled: false, layers: t, children: [
        (0, import_jsx_runtime.jsx)("planeGeometry", {}),
        (0, import_jsx_runtime.jsx)(
          "shaderMaterial",
          {
            fragmentShader: Ps,
            uniforms: {
              u_texture: { value: t2.texture }
            },
            vertexShader: Ss
          },
          Do(Ps + Ss)
        )
      ] }),
      e
    )
  ] });
}
function Wn(n2, t2, e) {
  return Math.max(t2, Math.min(e, n2));
}
function Oa(n2, t2, e) {
  return (1 - e) * n2 + e * t2;
}
function Pe2(n2, t2, e, i) {
  return Oa(n2, t2, 1 - Math.exp(-e * i));
}
var cn = new Matrix4();
var Pa = new Matrix4();
var Sa = {
  x: "XYZ",
  y: "YXZ",
  z: "ZXY"
};
function qn(n2, t2, e, i, s2, r2) {
  cn.copy(e), s2 != null && cn.premultiply(Pa.copy(s2).invert());
  const o2 = new Vector3(), a = new Quaternion(), l2 = new Vector3();
  cn.decompose(o2, a, l2), Ms(o2, i.initialTargetPosition, r2.translate ?? true);
  let c;
  const h = r2.rotate ?? true;
  if (h === false)
    a.copy(i.initialTargetQuaternion), c = i.initialTargetRotation.clone();
  else if (Array.isArray(h) || h === true || typeof h != "string" && !Array.isArray(h) && h.x === true && h.y === true && h.z === true)
    c = new Euler().setFromQuaternion(a, i.initialTargetRotation.order);
  else if (typeof h == "string") {
    const u = Sa[h];
    c = new Euler().setFromQuaternion(a, u);
    for (const p of u) {
      const y = p.toLowerCase();
      y !== h && (c[y] = 0);
    }
    c.order = i.initialTargetRotation.order, a.setFromEuler(c);
  } else
    c = Ra(a, i.initialTargetRotation, h);
  return (typeof r2.scale != "object" || !r2.scale.uniform) && Ms(l2, i.initialTargetScale, r2.scale ?? true), {
    pointerAmount: t2,
    position: o2,
    quaternion: a,
    rotation: c,
    scale: l2,
    time: n2
  };
}
var Se = new Plane();
var Ce = new Vector3();
var Ae = new Vector3();
var Ca = new Vector3();
var Aa = new Quaternion();
function Cs(n2, t2, e) {
  return Se.normal.copy(n2), Se.constant = 0, Ma(Ce, Se.normal), Ae.copy(Ce), Ae.applyQuaternion(Aa.copy(t2).invert().premultiply(e)), Se.projectPoint(Ce, Ce).normalize(), Se.projectPoint(Ae, Ae).normalize(), (Ca.crossVectors(Ce, Se.normal).dot(Ae) < 0 ? 1 : -1) * Ce.angleTo(Ae);
}
function Ma(n2, t2) {
  if (t2.x === 0) {
    n2.set(1, 0, 0);
    return;
  }
  if (t2.y === 0) {
    n2.set(0, 1, 0);
    return;
  }
  if (t2.z === 0) {
    n2.set(0, 0, 1);
    return;
  }
  n2.set(-t2.y, t2.x, 0);
}
function Ra(n2, t2, e) {
  let i = "", s2 = "";
  for (const a of t2.order)
    e[a.toLowerCase()] === false ? s2 += a : i += a;
  const r2 = i + s2, o2 = new Euler().setFromQuaternion(n2, r2);
  for (const a of r2) {
    const l2 = a.toLowerCase();
    o2[l2] = Hi(l2, o2[l2], t2[l2], e);
  }
  return n2.setFromEuler(o2), o2;
}
var hn = new Vector3();
var As = new Plane();
var za = new Vector3();
var Ha = new Vector3();
function Ms(n2, t2, e) {
  if (Array.isArray(e)) {
    switch (e.length) {
      case 0:
        n2.copy(t2);
        return;
      case 1:
        n2.sub(t2), Pr(n2, e[0] instanceof Vector3 ? e[0] : hn.fromArray(e[0])), n2.add(t2);
        return;
      case 2:
        hn.crossVectors(e[0] instanceof Vector3 ? e[0] : za.fromArray(e[0]), e[1] instanceof Vector3 ? e[1] : Ha.fromArray(e[1])), As.setFromNormalAndCoplanarPoint(hn, t2), As.projectPoint(n2, n2);
        return;
    }
    return;
  }
  n2.x = Hi("x", n2.x, t2.x, e), n2.y = Hi("y", n2.y, t2.y, e), n2.z = Hi("z", n2.z, t2.z, e);
}
function Hi(n2, t2, e, i) {
  if (typeof i == "boolean")
    return i ? t2 : e;
  if (typeof i == "string")
    return i === n2 ? t2 : e;
  const s2 = i[n2];
  return s2 === false ? e : Array.isArray(s2) ? Wn(t2, ...s2) : t2;
}
function Ne(n2 = true, t2, e, i, s2, r2) {
  if (n2) {
    switch (t2.length) {
      case 0:
      case 3:
        return;
      case 1:
        Ia(e, ...t2, i, s2, r2);
        return;
      case 2:
        La(...t2, e, i, s2, r2);
        return;
    }
    throw new Error(`space cannot be ${t2.length}D but received (${t2.map((o2) => o2.toArray().join("/")).join("; ")})`);
  }
}
var Li = {
  x: new Vector3(1, 0, 0),
  y: new Vector3(0, 1, 0),
  z: new Vector3(0, 0, 1)
};
function Xe(n2, t2, e, i, s2) {
  if (i !== false) {
    if (i === true) {
      n2[0] = Li.x, n2[1] = Li.y, n2[2] = Li.z;
      return;
    }
    if (typeof i == "string") {
      ii2(n2, t2, e, i, s2);
      return;
    }
    if (Array.isArray(i)) {
      for (const r2 of i)
        ii2(n2, t2, e, r2, s2);
      return;
    }
    i.x !== false && ii2(n2, t2, e, "x", s2), i.y !== false && ii2(n2, t2, e, "y", s2), i.z !== false && ii2(n2, t2, e, "z", s2);
  }
}
var he = new Quaternion();
var Ei = new Euler();
var Mt = new Vector3();
var Me = new Vector3();
var ue = new Vector3();
function ii2(n2, t2, e, i, s2) {
  if (Array.isArray(i) ? Mt.set(...i) : i instanceof Vector3 ? Mt.copy(i) : Mt.copy(Li[i]), s2 === "translate") {
    Mt.applyQuaternion(t2), Ti(n2, Mt);
    return;
  }
  if (s2 === "scale") {
    Array.isArray(i) ? he.identity() : he.setFromEuler(e), he.premultiply(t2), Mt.applyQuaternion(he), Ti(n2, Mt);
    return;
  }
  if (Array.isArray(i))
    Ei.set(0, 0, 0);
  else {
    Ei.copy(e);
    for (let r2 = 2; r2 >= 0; r2--) {
      const o2 = e.order[r2].toLowerCase();
      if (Ei[o2] = 0, o2 === i)
        break;
    }
  }
  he.setFromEuler(Ei).premultiply(t2), Mt.normalize(), Me.set(0, 1, 0), Mt.dot(Me) > 0.99 && Me.set(0, 0, 1), ue.crossVectors(Mt, Me).normalize(), Me.copy(ue), ue.applyQuaternion(he), Ti(n2, ue), ue.crossVectors(Mt, Me).normalize(), ue.applyQuaternion(he), Ti(n2, ue);
}
var Rs = new Vector3();
function Ti(n2, t2) {
  if (n2.length !== 3) {
    if (n2.length === 0) {
      n2.push(t2.clone());
      return;
    }
    if (n2.length === 1) {
      Math.abs(n2[0].dot(t2)) < 0.999 && n2.push(t2.clone());
      return;
    }
    Rs.crossVectors(n2[0], n2[1]), !(Math.abs(Rs.dot(t2)) < 1e-3) && n2.push(t2.clone());
  }
}
var ni2 = new Plane();
var un = new Vector3();
var pi = new Vector3();
function La(n2, t2, e, i, s2, r2) {
  un.crossVectors(n2, t2).normalize(), ni2.setFromNormalAndCoplanarPoint(un, e);
  const o2 = r2 == null ? 0 : Math.abs(un.dot(r2));
  if (r2 == null || o2 < 0.01) {
    ni2.projectPoint(s2, s2);
    return;
  }
  const l2 = -ni2.distanceToPoint(i) / r2.dot(ni2.normal);
  if (l2 < 0) {
    ni2.projectPoint(s2, s2);
    return;
  }
  pi.copy(s2), s2.copy(i).addScaledVector(r2, l2);
}
function Ia(n2, t2, e, i, s2) {
  const r2 = s2 == null ? 0 : 1 - Math.abs(t2.dot(s2));
  if (s2 == null || r2 < 1e-3) {
    zs(i, n2, t2);
    return;
  }
  pi.subVectors(e, n2);
  const o2 = t2.dot(s2), a = t2.dot(pi), l2 = s2.dot(pi), c = 1 - o2 * o2, h = (a - o2 * l2) / c;
  if ((o2 * a - l2) / c < 0) {
    zs(i, n2, t2);
    return;
  }
  pi.copy(i), i.copy(n2).addScaledVector(t2, h);
}
function zs(n2, t2, e) {
  n2.sub(t2), Pr(n2, e), n2.add(t2);
}
function Pr(n2, t2) {
  const e = n2.dot(t2);
  n2.copy(t2).multiplyScalar(e);
}
var dn = new Matrix4();
var Oi = new Matrix4();
var Pi = new Vector3();
var Ua = new Vector3();
var de = new Quaternion();
var Da = new Vector3(1, 1, 1);
var fn = [];
function ka(n2, t2, e, i, s2) {
  return i == null ? de.identity() : i.decompose(Pi, de, Ua), fn.length = 0, Xe(fn, de, e.initialTargetRotation, s2.translate ?? true, "translate"), Oi.makeRotationFromQuaternion(de.copy(t2.initialPointerWorldQuaternion).invert()).multiply(dn.makeTranslation(Pi.copy(t2.initialPointerWorldPoint).negate())), e.initialTargetParentWorldMatrix != null && Oi.multiply(e.initialTargetParentWorldMatrix), Ne(s2.projectRays, fn, t2.initialPointerWorldPoint, t2.pointerWorldOrigin, Pi.copy(t2.pointerWorldPoint), t2.pointerWorldDirection), de.copy(t2.pointerWorldQuaternion), (s2.rotate ?? true) === false && de.copy(t2.initialPointerWorldQuaternion), dn.compose(Pi, de, Da).multiply(Oi).multiply(Oi.compose(e.initialTargetPosition, e.initialTargetQuaternion, e.initialTargetScale)), qn(n2, 1, dn, e, i, s2);
}
var Re = new Vector3();
var si = new Vector3();
var nt = new Vector3();
var te = new Vector3();
var Fa = new Vector3();
var Hs = new Vector3();
var ze = new Vector3();
var Ls = new Matrix4();
var ri = new Matrix4();
var Si = new Matrix4();
var Zt = new Quaternion();
var oi = new Quaternion();
var He = [];
function Ya(n2, t2, e, i, s2, r2) {
  s2 == null ? Zt.identity() : s2.decompose(nt, Zt, te), He.length = 0, Xe(He, Zt, i.initialTargetRotation, r2.translate ?? true, "translate"), Xe(He, Zt, i.initialTargetRotation, r2.rotate ?? true, "rotate"), Xe(He, Zt, i.initialTargetRotation, r2.scale ?? true, "scale"), Ne(r2.projectRays, He, t2.initialPointerWorldPoint, t2.pointerWorldOrigin, nt.copy(t2.pointerWorldPoint), t2.pointerWorldDirection), Ne(r2.projectRays, He, e.initialPointerWorldPoint, e.pointerWorldOrigin, te.copy(e.pointerWorldPoint), e.pointerWorldDirection), Re.copy(e.initialPointerWorldPoint).sub(t2.initialPointerWorldPoint), si.copy(te).sub(nt), nt.copy(Re), i.prevTwoPointerDeltaRotation != null && nt.applyQuaternion(i.prevTwoPointerDeltaRotation), nt.normalize(), te.copy(si).normalize(), Zt.setFromUnitVectors(nt, te), i.prevTwoPointerDeltaRotation == null ? i.prevTwoPointerDeltaRotation = new Quaternion() : Zt.multiply(i.prevTwoPointerDeltaRotation), i.prevTwoPointerDeltaRotation.copy(Zt);
  const o2 = (Cs(te, t2.prevPointerWorldQuaternion, t2.pointerWorldQuaternion) + Cs(te, e.prevPointerWorldQuaternion, e.pointerWorldQuaternion)) * 0.5 + (i.prevAngle ?? 0);
  if (i.prevAngle = o2, Zt.premultiply(oi.setFromAxisAngle(te, o2)), Si.compose(i.initialTargetPosition, i.initialTargetQuaternion, i.initialTargetScale), i.initialTargetParentWorldMatrix != null && Si.premultiply(i.initialTargetParentWorldMatrix), typeof r2.scale == "object" && (r2.scale.uniform ?? false))
    ze.setScalar(si.length() / Re.length());
  else {
    Si.decompose(Fa, oi, Hs), nt.copy(Re).applyQuaternion(oi.invert()).divide(Hs), nt.x = Math.abs(nt.x), nt.y = Math.abs(nt.y), nt.z = Math.abs(nt.z);
    const a = Math.max(...nt.toArray());
    nt.divideScalar(a), ze.set(1, 1, 1), ze.addScaledVector(nt, si.length() / Re.length() - 1);
  }
  return Ls.makeTranslation(nt.copy(si).multiplyScalar(0.5).add(t2.pointerWorldPoint)).multiply(ri.makeRotationFromQuaternion(Zt)).multiply(ri.makeRotationFromQuaternion(oi.invert())).multiply(ri.makeScale(ze.x, ze.y, ze.z)).multiply(ri.makeRotationFromQuaternion(oi.invert())).multiply(ri.makeTranslation(nt.copy(Re).multiplyScalar(0.5).add(t2.initialPointerWorldPoint).negate())).multiply(Si), qn(n2, 2, Ls, i, s2, r2);
}
var K = new Vector3();
var Tt = new Vector3();
var pn = new Vector3();
var ee = new Vector3();
var fe = new Vector3();
var Ot = new Quaternion();
var vt = new Quaternion();
var ie = new Matrix4();
var jt = new Vector3();
var Le = [];
function Za(n2, t2, e, i, s2, r2) {
  if (s2 == null ? Ot.identity() : s2.decompose(K, Ot, Tt), Le.length = 0, r2.translate === "as-scale" && Xe(Le, Ot, e.initialTargetRotation, r2.scale ?? true, "scale"), r2.translate != "as-scale" && Xe(Le, Ot, e.initialTargetRotation, r2.rotate ?? true, "rotate"), ie.makeTranslation(e.initialTargetPosition), e.initialTargetParentWorldMatrix != null && ie.premultiply(e.initialTargetParentWorldMatrix), ee.setFromMatrixPosition(ie), Ne(r2.projectRays, Le, t2.initialPointerWorldPoint, t2.pointerWorldOrigin, ee, void 0), ee.negate().add(t2.initialPointerWorldPoint), fe.setFromMatrixPosition(i), Ne(r2.projectRays, Le, t2.initialPointerWorldPoint, t2.pointerWorldOrigin, fe, void 0), Ne(r2.projectRays, Le, t2.initialPointerWorldPoint, t2.pointerWorldOrigin, Tt.copy(t2.pointerWorldPoint), t2.pointerWorldDirection), fe.negate().add(Tt), r2.translate === "as-scale" ? Ot.copy(e.initialTargetQuaternion) : (K.copy(ee), e.prevTranslateAsDeltaRotation != null && K.applyQuaternion(e.prevTranslateAsDeltaRotation), K.normalize(), Tt.copy(fe).normalize(), Ot.setFromUnitVectors(K, Tt), e.prevTranslateAsDeltaRotation == null ? e.prevTranslateAsDeltaRotation = new Quaternion() : Ot.multiply(e.prevTranslateAsDeltaRotation), e.prevTranslateAsDeltaRotation.copy(Ot), e.initialTargetParentWorldMatrix != null && (vt.setFromRotationMatrix(e.initialTargetParentWorldMatrix), Ot.multiply(vt.normalize()), Ot.premultiply(vt.invert())), Ot.multiply(e.initialTargetQuaternion)), r2.translate === "as-rotate")
    jt.set(1, 1, 1);
  else if (typeof r2.scale == "object" && (r2.scale.uniform ?? false))
    jt.setScalar(fe.length() / ee.length());
  else if (r2.translate === "as-rotate-and-scale") {
    ie.compose(e.initialTargetPosition, e.initialTargetQuaternion, e.initialTargetScale), e.initialTargetParentWorldMatrix != null && ie.premultiply(e.initialTargetParentWorldMatrix), ie.decompose(Tt, vt, pn), K.copy(ee).applyQuaternion(vt.invert()).divide(pn), K.x = Math.abs(K.x), K.y = Math.abs(K.y), K.z = Math.abs(K.z);
    const o2 = Math.max(...K.toArray());
    K.divideScalar(o2), jt.set(1, 1, 1), jt.addScaledVector(K, fe.length() / ee.length() - 1);
  } else
    e.initialTargetParentWorldMatrix != null ? (e.initialTargetParentWorldMatrix.decompose(K, vt, Tt), vt.multiply(e.initialTargetQuaternion)) : vt.copy(e.initialTargetQuaternion), K.copy(ee).applyQuaternion(vt.invert()), s2 != null ? (s2.decompose(Tt, vt, pn), vt.multiply(e.initialTargetQuaternion)) : vt.copy(e.initialTargetQuaternion), Tt.copy(fe).applyQuaternion(vt.invert()), jt.x = Math.abs(K.x) < 1e-3 ? 1 : Math.abs(Tt.x / K.x), jt.y = Math.abs(K.y) < 1e-3 ? 1 : Math.abs(Tt.y / K.y), jt.z = Math.abs(K.z) < 1e-3 ? 1 : Math.abs(Tt.z / K.z);
  return jt.multiply(e.initialTargetScale), ie.compose(e.initialTargetPosition, Ot, jt), qn(n2, 1, ie, e, void 0, r2);
}
var Is = class {
  constructor(t2, e) {
    f(this, "t1");
    f(this, "t2");
    f(this, "_position");
    f(this, "_quaternion");
    f(this, "_rotation");
    f(this, "_scale");
    this.t1 = t2, this.t2 = e;
  }
  get time() {
    return this.t1.time - this.t2.time;
  }
  get position() {
    return this._position ?? (this._position = this.t1.position.clone().sub(this.t2.position));
  }
  get quaternion() {
    return this._quaternion ?? (this._quaternion = this.t2.quaternion.clone().invert().premultiply(this.t1.quaternion));
  }
  get rotation() {
    return this._rotation ?? (this._rotation = new Euler().setFromQuaternion(this.quaternion));
  }
  get scale() {
    return this._scale ?? (this._scale = this.t1.scale.clone().sub(this.t2.scale));
  }
};
var Na = class {
  constructor(t2) {
    f(this, "cancel");
    f(this, "previous");
    f(this, "memo");
    f(this, "event");
    f(this, "initial");
    f(this, "current");
    f(this, "first");
    f(this, "last");
    f(this, "_delta");
    f(this, "_offset");
    this.cancel = t2;
  }
  start(t2, e) {
    this.event = t2, this.previous = void 0, this.current = e, this.initial = e, this.first = true, this.last = false, this.memo = void 0, this._delta = void 0, this._offset = void 0;
  }
  update(t2, e) {
    this.event = t2, this.previous = this.current, this.current = e, this.first = false, this.last = false, this._delta = void 0, this._offset = void 0;
  }
  end(t2) {
    this.event = t2, this.first = false, this.last = true, this._delta = void 0, this._offset = void 0;
  }
  get delta() {
    if (this.previous != null)
      return this._delta ?? (this._delta = new Is(this.current, this.previous));
  }
  get offset() {
    return this._offset ?? (this._offset = new Is(this.current, this.initial));
  }
};
function Us(n2, t2) {
  if (n2.details.type === "sphere")
    return false;
  if (n2.details.type === "lines") {
    const { line: e } = n2.details;
    return t2.copy(e.end).sub(e.start).normalize(), true;
  }
  return n2.details.type === "screen-ray" ? (t2.copy(n2.details.direction), true) : (t2.set(0, 0, -1).applyQuaternion(n2.pointerQuaternion), true);
}
var Ds = new Vector3();
var Sr = class {
  constructor(t2, e = () => ({})) {
    f(this, "target");
    f(this, "getOptions");
    f(this, "outputState");
    f(this, "latestMoveEvent");
    f(this, "inputState", /* @__PURE__ */ new Map());
    f(this, "capturedObjects", /* @__PURE__ */ new Map());
    f(this, "initialTargetPosition", new Vector3());
    f(this, "initialTargetQuaternion", new Quaternion());
    f(this, "initialTargetRotation", new Euler());
    f(this, "initialTargetScale", new Vector3());
    f(this, "initialTargetParentWorldMatrix");
    f(this, "prevTwoPointerDeltaRotation");
    f(this, "prevTranslateAsDeltaRotation");
    f(this, "prevAngle");
    f(this, "handlers", {
      onPointerDown: this.onPointerDown.bind(this),
      onPointerMove: this.onPointerMove.bind(this),
      onPointerUp: this.onPointerUp.bind(this)
    });
    this.target = t2, this.getOptions = e, this.outputState = new Na(this.cancel.bind(this));
  }
  /**
   * @requires that the pointerId is in this.capturedSet
   */
  firstOnPointer(t2) {
    const e = this.getTarget();
    if (e == null)
      return;
    const i = Us(t2, Ds) ? Ds.clone() : void 0;
    t2.intersection.details.type, this.inputState.set(t2.pointerId, {
      pointerWorldDirection: i,
      pointerWorldPoint: t2.point,
      pointerWorldOrigin: t2.pointerPosition,
      pointerWorldQuaternion: t2.pointerQuaternion,
      initialPointerWorldPoint: t2.point.clone(),
      initialPointerWorldDirection: i == null ? void 0 : i.clone(),
      initialPointerWorldQuaternion: t2.pointerQuaternion.clone(),
      prevPointerWorldQuaternion: t2.pointerQuaternion
    }), this.save(), this.inputState.size === 1 && this.outputState.start(t2, {
      pointerAmount: 1,
      time: t2.timeStamp,
      position: this.initialTargetPosition.clone(),
      quaternion: this.initialTargetQuaternion.clone(),
      rotation: this.initialTargetRotation.clone(),
      scale: this.initialTargetScale.clone()
    }), this.outputState.memo = this.apply(e);
  }
  onPointerDown(t2) {
    this.stopPropagation(t2), this.capturePointer(t2.pointerId, t2.object) && this.firstOnPointer(t2);
  }
  onPointerMove(t2) {
    if (!this.capturedObjects.has(t2.pointerId))
      return;
    this.stopPropagation(t2);
    const e = this.inputState.get(t2.pointerId);
    if (e == null) {
      this.firstOnPointer(t2);
      return;
    }
    this.latestMoveEvent = t2, e.pointerWorldPoint = t2.point, e.prevPointerWorldQuaternion = e.pointerWorldQuaternion, e.pointerWorldQuaternion = t2.pointerQuaternion, e.pointerWorldOrigin = t2.pointerPosition, e.pointerWorldDirection != null && Us(t2, e.pointerWorldDirection);
  }
  cancel() {
    if (this.capturedObjects.size === 0)
      return;
    for (const [e, i] of this.capturedObjects)
      i.releasePointerCapture(e);
    this.capturedObjects.clear(), this.inputState.clear(), this.outputState.end(void 0);
    const t2 = this.getTarget();
    t2 != null && this.apply(t2);
  }
  onPointerUp(t2) {
    this.capturedObjects.has(t2.pointerId) && (this.stopPropagation(t2), this.releasePointer(t2.pointerId, t2.object, t2));
  }
  update(t2) {
    var r2, o2, a;
    const e = this.getTarget();
    if (e == null || this.inputState.size === 0 || this.latestMoveEvent == null && (this.getOptions().alwaysUpdate ?? false) === false)
      return;
    const i = this.getOptions();
    let s2;
    if (i.translate === "as-rotate" || i.translate === "as-rotate-and-scale" || i.translate === "as-scale") {
      i.translate, this.prevTwoPointerDeltaRotation = void 0, this.prevAngle = void 0;
      const [l2] = this.inputState.values(), c = e.matrixWorld, h = (r2 = e.parent) == null ? void 0 : r2.matrixWorld;
      s2 = Za(t2, l2, this, c, h, i);
    } else if (this.inputState.size === 1) {
      this.prevTwoPointerDeltaRotation = void 0, this.prevAngle = void 0, this.prevTranslateAsDeltaRotation = void 0;
      const [l2] = this.inputState.values();
      s2 = ka(t2, l2, this, (o2 = e.parent) == null ? void 0 : o2.matrixWorld, i);
    } else {
      this.prevTranslateAsDeltaRotation = void 0;
      const [l2, c] = this.inputState.values();
      s2 = Ya(t2, l2, c, this, (a = e.parent) == null ? void 0 : a.matrixWorld, i);
    }
    this.outputState.update(this.latestMoveEvent, s2), this.outputState.memo = this.apply(e), this.latestMoveEvent = void 0;
  }
  getTarget() {
    var t2;
    return this.target instanceof Object3D ? this.target : (t2 = this.target) == null ? void 0 : t2.current;
  }
  capturePointer(t2, e) {
    if (this.capturedObjects.has(t2))
      return false;
    const { multitouch: i, translate: s2 } = this.getOptions();
    return ((i ?? true) === false || typeof s2 == "string") && this.capturedObjects.size === 1 ? false : (this.capturedObjects.set(t2, e), e.setPointerCapture(t2), true);
  }
  releasePointer(t2, e, i) {
    const s2 = this.getTarget();
    if (!(s2 == null || !this.capturedObjects.delete(t2))) {
      if (this.inputState.delete(t2), e.releasePointerCapture(t2), this.inputState.size > 0) {
        this.save();
        return;
      }
      this.outputState.end(i), this.apply(s2);
    }
  }
  stopPropagation(t2) {
    var e;
    t2 == null || !(((e = this.getOptions()) == null ? void 0 : e.stopPropagation) ?? true) || t2.stopPropagation();
  }
  apply(t2) {
    return (this.getOptions().apply ?? Bn)(this.outputState, t2);
  }
  getState() {
    return this.inputState.size === 0 ? void 0 : this.outputState;
  }
  save() {
    var e, i;
    const t2 = this.getTarget();
    if (t2 != null) {
      t2.updateWorldMatrix(true, false), this.prevAngle = void 0, this.prevTwoPointerDeltaRotation = void 0, this.prevTranslateAsDeltaRotation = void 0, this.initialTargetParentWorldMatrix = (e = t2.parent) == null ? void 0 : e.matrixWorld.clone(), t2.matrixAutoUpdate ? (this.initialTargetPosition.copy(t2.position), this.initialTargetQuaternion.copy(t2.quaternion), this.initialTargetRotation.copy(t2.rotation), this.initialTargetScale.copy(t2.scale)) : (t2.matrix.decompose(this.initialTargetPosition, this.initialTargetQuaternion, this.initialTargetScale), this.initialTargetRotation.setFromQuaternion(this.initialTargetQuaternion, t2.rotation.order));
      for (const s2 of this.inputState.values())
        s2.pointerWorldDirection != null && ((i = s2.initialPointerWorldDirection) == null || i.copy(s2.pointerWorldDirection)), s2.initialPointerWorldPoint.copy(s2.pointerWorldPoint), s2.initialPointerWorldQuaternion.copy(s2.pointerWorldQuaternion);
    }
  }
  bind(t2) {
    const { onPointerDown: e, onPointerMove: i, onPointerUp: s2 } = this.handlers;
    return t2.addEventListener("pointerdown", e), t2.addEventListener("pointermove", i), t2.addEventListener("pointerup", s2), () => {
      t2.removeEventListener("pointerdown", e), t2.removeEventListener("pointermove", i), t2.removeEventListener("pointerup", s2), this.cancel();
    };
  }
  capture(t2, e) {
    return this.capturePointer(t2, e) ? () => this.releasePointer(t2, e, void 0) : Xa;
  }
};
function Xa() {
}
function Bn(n2, t2) {
  t2.position.copy(n2.current.position), t2.rotation.order = n2.current.rotation.order, t2.quaternion.copy(n2.current.quaternion), t2.scale.copy(n2.current.scale);
}
var Cr = class {
  constructor(t2, e) {
    f(this, "target");
    f(this, "getOptions");
    f(this, "handles", []);
    f(this, "hoveredTagMap", /* @__PURE__ */ new Map());
    f(this, "hoverSubscriptions", []);
    f(this, "applySubscriptions", []);
    f(this, "space");
    this.target = t2, this.getOptions = e;
  }
  getSpace() {
    return this.space ?? "world";
  }
  getTarget() {
    return this.target instanceof Object3D ? this.target : this.target.current;
  }
  getHandleOptions(t2, e) {
    var r2;
    const i = (r2 = this.getOptions) == null ? void 0 : r2.call(this), s2 = e == null ? void 0 : e();
    return {
      ...i,
      ...s2,
      apply: (o2, a) => {
        var l2;
        return this.onApply(t2, o2, a), (l2 = (s2 == null ? void 0 : s2.apply) ?? (i == null ? void 0 : i.apply) ?? Bn) == null ? void 0 : l2(o2, a);
      }
    };
  }
  registerHandle(t2, e, i) {
    const s2 = {
      object: e,
      store: t2,
      tag: i
    };
    this.handles.push(s2);
    const r2 = t2.bind(e), o2 = this.onPointerEnter.bind(this, i), a = this.onPointerLeave.bind(this);
    return e.addEventListener("pointerenter", o2), e.addEventListener("pointerleave", a), () => {
      const l2 = this.handles.indexOf(s2);
      l2 != -1 && this.handles.splice(l2, 1), r2(), t2.cancel();
    };
  }
  subscribeHover(t2) {
    return this.hoverSubscriptions.push(t2), t2(Array.from(this.hoveredTagMap.values())), () => {
      const e = this.hoverSubscriptions.indexOf(t2);
      e !== -1 && this.hoverSubscriptions.splice(e, 1);
    };
  }
  subscribeApply(t2) {
    return this.applySubscriptions.push(t2), () => {
      const e = this.applySubscriptions.indexOf(t2);
      e !== -1 && this.applySubscriptions.splice(e, 1);
    };
  }
  update(t2) {
    for (const { store: e } of this.handles)
      e.update(t2);
  }
  onPointerEnter(t2, e) {
    this.hoveredTagMap.set(e.pointerId, t2), this.updateHover();
  }
  onPointerLeave(t2) {
    this.hoveredTagMap.delete(t2.pointerId), this.updateHover();
  }
  updateHover() {
    const t2 = Array.from(this.hoveredTagMap.values());
    for (const e of this.hoverSubscriptions)
      e(t2);
  }
  onApply(t2, e, i) {
    for (const s2 of this.applySubscriptions)
      s2(t2, e, i);
  }
};
var at = {
  depthTest: false,
  depthWrite: false,
  fog: false,
  toneMapped: false,
  transparent: true
};
function bt(n2, t2, e, { color: i, hoverColor: s2, hoverOpacity: r2, opacity: o2, disabled: a = false }) {
  if (s2 == null && r2 == null || a) {
    t2.color.set(i), t2.opacity = o2 ?? 1, a && (t2.opacity *= 0.5, t2.color.lerp(new Color(1, 1, 1), 0.5));
    return;
  }
  return s2 ?? (s2 = i), n2.subscribeHover((l2) => {
    const c = l2.some((h) => h.includes(e));
    t2.color.set(c ? s2 : i), t2.opacity = (c ? r2 : o2) ?? 1;
  });
}
var Ci = new Quaternion();
var Ar = new BufferGeometry();
Ar.setAttribute("position", new Float32BufferAttribute([-1e3, 0, 0, 1e3, 0, 0], 3));
var Va = class extends LineSegments {
  constructor(e, i) {
    super(Ar);
    f(this, "context");
    f(this, "rotationOffset");
    this.context = e, this.rotationOffset = i, this.renderOrder = 1 / 0;
  }
  update() {
    this.quaternion.setFromEuler(this.rotationOffset);
    const e = this.context.getTarget();
    this.context.getSpace() === "world" && e != null && (e.getWorldQuaternion(Ci).invert(), this.quaternion.premultiply(Ci));
  }
  bind(e) {
    this.material = new LineBasicMaterial({
      ...at,
      color: this.material.color ?? "white",
      opacity: this.material.opacity ?? 1
    });
    const i = this.context.subscribeHover((r2) => {
      const o2 = r2.some((a) => a.includes(e));
      this.visible = o2;
    }), s2 = this.context.subscribeApply((r2, o2) => {
      if (o2.last) {
        this.position.set(0, 0, 0);
        return;
      }
      this.position.copy(o2.initial.position).sub(o2.current.position);
      const a = this.context.getTarget();
      a != null && (Ci.copy(a.quaternion).invert(), this.position.applyQuaternion(Ci));
    });
    return () => {
      this.material.dispose(), i(), s2();
    };
  }
};
var Ut = class extends Group {
  constructor(e, i, s2, r2) {
    super();
    f(this, "context");
    f(this, "axis");
    f(this, "store");
    f(this, "options");
    f(this, "tag");
    this.context = e, this.axis = i, this.tag = (s2 ?? "") + i, this.store = new Sr(e.target, () => e.getHandleOptions(this.tag, r2));
  }
};
function Dt(n2, t2 = true) {
  if (t2 === false)
    return { options: false, disabled: true };
  if (t2 === true) {
    const s2 = {
      x: false,
      y: false,
      z: false,
      e: false
    };
    for (const r2 of n2)
      s2[r2] = true;
    return { options: s2, disabled: false };
  }
  if (t2 === "disabled")
    return { options: { x: true, y: true, z: true, e: true }, disabled: true };
  if (typeof t2 == "string")
    return {
      options: t2 === n2 ? {
        x: false,
        y: false,
        z: false,
        e: false,
        [n2]: true
      } : false,
      disabled: false
    };
  const e = {
    x: false,
    y: false,
    z: false,
    e: false
  };
  let i = false;
  for (const s2 of n2) {
    let r2 = t2[s2] ?? true;
    if (r2 === false)
      return { options: false, disabled: true };
    r2 === "disabled" && (i = true, r2 = true), e[s2] = r2;
  }
  return { options: e, disabled: i };
}
var ks = new Vector3();
var Fs = new Vector3();
function Bi(n2, t2, e, i) {
  if (!e)
    return i;
  let s2;
  return t2 instanceof OrthographicCamera ? s2 = (t2.top - t2.bottom) / t2.zoom : (t2.getWorldPosition(ks), n2.getWorldPosition(Fs), s2 = ks.distanceTo(Fs) * Math.min(1.9 * Math.tan(Math.PI * t2.fov / 360) / t2.zoom, 7)), s2 * i / 4;
}
var mn = class extends Ut {
  constructor(t2, e, i) {
    super(t2, e, i, () => ({
      scale: this.options,
      rotate: false,
      translate: "as-scale",
      multitouch: false
    }));
  }
  bind(t2, e) {
    const { options: i, disabled: s2 } = Dt(this.axis, e);
    if (i === false)
      return;
    this.options = i;
    const r2 = new MeshBasicMaterial(at), o2 = bt(this.context, r2, this.tag, {
      color: t2,
      hoverColor: 16777024,
      disabled: s2
    }), a = new Mesh(new SphereGeometry(0.04), r2);
    a.renderOrder = 1 / 0, a.pointerEventsOrder = 1 / 0, a.position.x = 0.68;
    const l2 = s2 ? void 0 : this.context.registerHandle(this.store, a, this.tag);
    return this.add(a), () => {
      r2.dispose(), a.geometry.dispose(), l2 == null || l2(), o2 == null || o2(), this.remove(a);
    };
  }
};
var gn = class extends Ut {
  constructor(t2, e, i, s2) {
    super(t2, e, i, () => ({
      scale: false,
      translate: "as-rotate",
      rotate: s2 != null ? [s2] : this.options,
      multitouch: false
    }));
  }
  bind(t2, e) {
    const { options: i, disabled: s2 } = Dt(this.axis, e);
    if (i === false)
      return;
    this.options = i;
    const r2 = new MeshBasicMaterial(at), o2 = bt(this.context, r2, this.tag, {
      color: t2,
      hoverColor: 16777024,
      disabled: s2
    }), a = new Mesh(new TorusGeometry(0.45, 75e-4, 3, 64, Math.PI / 2), r2);
    a.renderOrder = 1 / 0, a.rotation.set(0, Math.PI / 2, Math.PI / 2), this.add(a);
    const l2 = new Mesh(new TorusGeometry(0.45, 0.05, 4, 24, Math.PI / 2));
    l2.pointerEventsOrder = 1 / 0, l2.visible = false, l2.rotation.set(0, Math.PI / 2, Math.PI / 2), this.add(l2);
    const c = s2 ? void 0 : this.context.registerHandle(this.store, l2, this.tag);
    return () => {
      r2.dispose(), l2.geometry.dispose(), a.geometry.dispose(), c == null || c(), o2 == null || o2(), this.remove(a), this.remove(l2);
    };
  }
};
var Mr = new CylinderGeometry(0, 0.04, 0.1, 12);
Mr.translate(0, 0.05, 0);
var Rr = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
Rr.translate(0, 0.25, 0);
var Qa = new Euler(0, 0, -Math.PI / 2);
var ja = new Euler(0, 0, Math.PI / 2);
var qt = class extends Ut {
  constructor(e, i, s2 = "", r2, o2 = false, a = true) {
    super(e, i, s2, () => ({
      scale: false,
      rotate: false,
      translate: r2 != null ? [r2] : this.options,
      multitouch: false
    }));
    f(this, "invert");
    f(this, "showArrowBody");
    this.invert = o2, this.showArrowBody = a;
  }
  bind(e, i, s2) {
    const { options: r2, disabled: o2 } = Dt(this.axis, s2);
    if (r2 === false)
      return;
    this.options = r2;
    const a = this.invert ? ja : Qa, l2 = new MeshBasicMaterial(at), c = bt(this.context, l2, this.tag, {
      color: e,
      hoverColor: i,
      disabled: o2
    }), h = new Mesh(Mr, l2);
    h.renderOrder = 1 / 0, h.position.x = this.invert ? -0.5 : 0.5, h.rotation.copy(a), this.add(h);
    let u, p;
    if (this.showArrowBody) {
      const b = new MeshBasicMaterial(at);
      u = bt(this.context, b, this.tag, {
        color: e,
        hoverColor: 16777024,
        disabled: o2
      }), p = new Mesh(Rr, b), p.renderOrder = 1 / 0, p.rotation.copy(a), this.add(p);
    }
    const y = new Mesh(new CylinderGeometry(0.13, 0, 0.6, 4));
    y.pointerEventsOrder = 1 / 0, y.position.x = this.invert ? -0.3 : 0.3, y.rotation.copy(a), y.visible = false, this.add(y);
    const T = o2 ? void 0 : this.context.registerHandle(this.store, y, this.tag);
    return () => {
      l2.dispose(), T == null || T(), c == null || c(), u == null || u(), this.remove(h), p != null && this.remove(p), this.remove(y);
    };
  }
};
var Ve = class extends Ut {
  constructor(t2, e, i = "", s2) {
    super(t2, e, i, () => ({
      translate: s2 ?? this.options,
      scale: false,
      rotate: false,
      multitouch: false
    }));
  }
  bind(t2, e, i) {
    const { options: s2, disabled: r2 } = Dt(this.axis, i);
    if (s2 === false)
      return;
    this.options = s2;
    const o2 = new MeshBasicMaterial(at), a = bt(this.context, o2, this.tag, {
      opacity: 0.5,
      hoverOpacity: 1,
      color: t2,
      hoverColor: e,
      disabled: r2
    }), l2 = new Mesh(new BoxGeometry(0.2, 0.2, 0.01), o2);
    l2.renderOrder = 1 / 0, l2.pointerEventsOrder = 1 / 0, l2.position.set(0.15, 0.15, 0);
    const c = r2 ? void 0 : this.context.registerHandle(this.store, l2, this.tag);
    return this.add(l2), () => {
      o2.dispose(), l2.geometry.dispose(), c == null || c(), a == null || a(), this.remove(l2);
    };
  }
};
var Ys = new Vector3();
var Wa = class extends Group {
  constructor(e, i, s2) {
    super();
    f(this, "context");
    f(this, "size");
    f(this, "fixed");
    f(this, "scaleX");
    f(this, "scaleY");
    f(this, "scaleZ");
    f(this, "rotationX");
    f(this, "rotationY");
    f(this, "rotationZ");
    f(this, "translationX");
    f(this, "translationY");
    f(this, "translationZ");
    f(this, "translationXY");
    f(this, "translationYZ");
    f(this, "translationXZ");
    f(this, "xAxis", new Vector3());
    f(this, "yAxis", new Vector3());
    f(this, "zAxis", new Vector3());
    f(this, "xRotationAxis", new Vector3());
    f(this, "yRotationAxis", new Vector3());
    f(this, "zRotationAxis", new Vector3());
    this.context = e, this.size = i, this.fixed = s2, this.scaleX = new mn(e, "x", "s"), this.add(this.scaleX), this.scaleY = new mn(e, "y", "s"), this.scaleY.rotation.z = Math.PI / 2, this.add(this.scaleY), this.scaleZ = new mn(e, "z", "s"), this.scaleZ.rotation.y = -Math.PI / 2, this.add(this.scaleZ), this.rotationX = new gn(e, "x", "r", this.xRotationAxis), this.add(this.rotationX), this.rotationY = new gn(e, "y", "r", this.yRotationAxis), this.rotationY.rotation.z = -Math.PI / 2, this.add(this.rotationY), this.rotationZ = new gn(e, "z", "r", this.zRotationAxis), this.rotationZ.rotation.y = Math.PI / 2, this.add(this.rotationZ), this.translationX = new qt(e, "x", "ta", this.xAxis), this.add(this.translationX), this.translationY = new qt(e, "y", "ta", this.yAxis), this.translationY.rotation.z = Math.PI / 2, this.add(this.translationY), this.translationZ = new qt(e, "z", "ta", this.zAxis), this.translationZ.rotation.y = -Math.PI / 2, this.add(this.translationZ), this.translationXY = new Ve(e, "xy", "tp", [this.xAxis, this.yAxis]), this.add(this.translationXY), this.translationYZ = new Ve(e, "yz", "tp", [this.yAxis, this.zAxis]), this.translationYZ.rotation.y = -Math.PI / 2, this.add(this.translationYZ), this.translationXZ = new Ve(e, "xz", "tp", [this.xAxis, this.zAxis]), this.translationXZ.rotation.x = Math.PI / 2, this.add(this.translationXZ);
  }
  update(e) {
    this.updateWorldMatrix(true, false);
    const i = this.context.getTarget();
    i != null && (Ie(this.xAxis, i, void 0, 1, 0, 0), Ie(this.yAxis, i, void 0, 0, 1, 0), Ie(this.zAxis, i, void 0, 0, 0, 1), Ie(this.xRotationAxis, i, this.rotationX.store, 1, 0, 0), Ie(this.yRotationAxis, i, this.rotationY.store, 0, 1, 0), Ie(this.zRotationAxis, i, this.rotationZ.store, 0, 0, 1)), this.scale.setScalar(1), i != null && (i.getWorldScale(Ys), this.scale.divide(Ys)), this.scale.multiplyScalar(Bi(this, e, this.fixed ?? true, this.size ?? 1));
  }
  bind(e, i, s2) {
    const r2 = this.scaleX.bind(16719968, s2), o2 = this.scaleY.bind(2154368, s2), a = this.scaleZ.bind(2130175, s2), l2 = this.rotationX.bind(16719968, i), c = this.rotationY.bind(2154368, i), h = this.rotationZ.bind(2130175, i), u = this.translationX.bind(16719968, 16777024, e), p = this.translationY.bind(2154368, 16777024, e), y = this.translationZ.bind(2130175, 16777024, e), T = this.translationXY.bind(16719968, 16777024, e), b = this.translationYZ.bind(2130175, 16777024, e), d2 = this.translationXZ.bind(2154368, 16777024, e);
    return () => {
      r2 == null || r2(), o2 == null || o2(), a == null || a(), l2 == null || l2(), c == null || c(), h == null || h(), u == null || u(), p == null || p(), y == null || y(), T == null || T(), b == null || b(), d2 == null || d2();
    };
  }
};
function Ie(n2, t2, e, ...[i, s2, r2]) {
  (e == null ? void 0 : e.getState()) == null && (n2.set(i, s2, r2), n2.applyQuaternion(t2.quaternion));
}
var Zs = new Quaternion();
function qa(n2, t2) {
  const e = new Mesh(new OctahedronGeometry(0.01, 2), new MeshBasicMaterial(at));
  e.renderOrder = 1 / 0, e.visible = false, n2.add(e);
  const i = new Mesh(new OctahedronGeometry(0.01, 2), new MeshBasicMaterial(at));
  i.renderOrder = 1 / 0, i.visible = false, n2.add(i);
  const s2 = new BufferGeometry();
  s2.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
  const r2 = new LineSegments(s2, new LineBasicMaterial(at));
  r2.renderOrder = 1 / 0, r2.visible = false, n2.add(r2);
  const o2 = t2.subscribeApply((a, l2) => {
    i.position.set(0, 0, 0), e.position.copy(l2.initial.position).sub(l2.current.position);
    const c = t2.getTarget();
    c != null && (Zs.copy(c.quaternion).invert(), e.position.applyQuaternion(Zs)), r2.position.set(0, 0, 0), r2.scale.copy(e.position), e.visible = !l2.last, r2.visible = !l2.last, i.visible = !l2.last;
  });
  return () => {
    e.geometry.dispose(), e.material.dispose(), i.geometry.dispose(), i.material.dispose(), r2.geometry.dispose(), r2.material.dispose(), n2.remove(e), n2.remove(i), n2.remove(r2), o2();
  };
}
var Ba = class extends Ut {
  constructor(t2) {
    super(t2, "xyz", "", () => ({
      translate: this.options,
      scale: false,
      rotate: false,
      multitouch: false
    }));
  }
  bind(t2) {
    const { options: e, disabled: i } = Dt(this.axis, t2);
    if (e === false)
      return;
    this.options = e;
    const s2 = new MeshBasicMaterial(at), r2 = bt(this.context, s2, this.tag, {
      color: 16777215,
      hoverColor: 16776960,
      opacity: 0.25,
      hoverOpacity: 1,
      disabled: i
    }), o2 = new Mesh(new OctahedronGeometry(0.1, 0), s2);
    o2.renderOrder = 1 / 0, this.add(o2);
    const a = new Mesh(new OctahedronGeometry(0.2, 0));
    a.pointerEventsOrder = 1 / 0, a.visible = false, this.add(a);
    const l2 = i ? void 0 : this.context.registerHandle(this.store, a, this.tag);
    return () => {
      s2.dispose(), o2.geometry.dispose(), a.geometry.dispose(), l2 == null || l2(), r2 == null || r2(), this.remove(o2), this.remove(a);
    };
  }
};
var Ns = new Vector3();
var mt = new Quaternion();
var Xs = new Quaternion();
var Vs = new Quaternion().setFromEuler(new Euler(0, 0, Math.PI / 2));
var Qs = new Quaternion().setFromEuler(new Euler(0, -Math.PI / 2, 0));
var $a = new Quaternion();
var Ga = new Quaternion().setFromEuler(new Euler(0, -Math.PI / 2, 0));
var Ka = new Quaternion().setFromEuler(new Euler(Math.PI / 2, 0, 0));
var Ja = class extends Group {
  constructor(e, i, s2) {
    super();
    f(this, "context");
    f(this, "size");
    f(this, "fixed");
    f(this, "free");
    f(this, "translationX");
    f(this, "translationY");
    f(this, "translationZ");
    f(this, "translationNegX");
    f(this, "translationNegY");
    f(this, "translationNegZ");
    f(this, "translationXY");
    f(this, "translationYZ");
    f(this, "translationXZ");
    f(this, "scaleGroup", new Group());
    f(this, "xAxis", new Vector3());
    f(this, "yAxis", new Vector3());
    f(this, "zAxis", new Vector3());
    f(this, "negXAxis", new Vector3());
    f(this, "negYAxis", new Vector3());
    f(this, "negZAxis", new Vector3());
    this.context = e, this.size = i, this.fixed = s2, this.add(this.scaleGroup), this.free = new Ba(this.context), this.scaleGroup.add(this.free), this.translationX = new qt(this.context, "x", void 0, this.xAxis), this.scaleGroup.add(this.translationX), this.translationY = new qt(this.context, "y", void 0, this.yAxis), this.scaleGroup.add(this.translationY), this.translationZ = new qt(this.context, "z", void 0, this.zAxis), this.scaleGroup.add(this.translationZ), this.translationNegX = new qt(this.context, "x", void 0, this.negXAxis, true, false), this.scaleGroup.add(this.translationNegX), this.translationNegY = new qt(this.context, "y", void 0, this.negYAxis, true, false), this.scaleGroup.add(this.translationNegY), this.translationNegZ = new qt(this.context, "z", void 0, this.negZAxis, true, false), this.scaleGroup.add(this.translationNegZ), this.translationXY = new Ve(this.context, "xy", void 0, [this.xAxis, this.yAxis]), this.scaleGroup.add(this.translationXY), this.translationXZ = new Ve(this.context, "xz", void 0, [this.xAxis, this.zAxis]), this.scaleGroup.add(this.translationXZ), this.translationYZ = new Ve(this.context, "yz", void 0, [this.yAxis, this.zAxis]), this.scaleGroup.add(this.translationYZ);
  }
  update(e) {
    this.updateWorldMatrix(true, false), this.xAxis.set(1, 0, 0), this.yAxis.set(0, 1, 0), this.zAxis.set(0, 0, 1), this.free.quaternion.identity(), this.translationX.quaternion.copy(Xs), this.translationY.quaternion.copy(Vs), this.translationZ.quaternion.copy(Qs), this.translationNegX.quaternion.copy(Xs), this.translationNegY.quaternion.copy(Vs), this.translationNegZ.quaternion.copy(Qs), this.translationXY.quaternion.copy($a), this.translationYZ.quaternion.copy(Ga), this.translationXZ.quaternion.copy(Ka);
    const i = this.context.getSpace(), s2 = this.context.getTarget();
    i == "world" && s2 != null ? (s2.getWorldQuaternion(mt).invert(), this.free.quaternion.premultiply(mt), this.translationX.quaternion.premultiply(mt), this.translationY.quaternion.premultiply(mt), this.translationZ.quaternion.premultiply(mt), this.translationNegX.quaternion.premultiply(mt), this.translationNegY.quaternion.premultiply(mt), this.translationNegZ.quaternion.premultiply(mt), this.translationXY.quaternion.premultiply(mt), this.translationYZ.quaternion.premultiply(mt), this.translationXZ.quaternion.premultiply(mt), s2.parent != null && (s2.parent.getWorldQuaternion(mt).invert(), this.xAxis.applyQuaternion(mt), this.yAxis.applyQuaternion(mt), this.zAxis.applyQuaternion(mt))) : s2 != null && (this.xAxis.applyQuaternion(s2.quaternion), this.yAxis.applyQuaternion(s2.quaternion), this.zAxis.applyQuaternion(s2.quaternion)), this.negXAxis.copy(this.xAxis).negate(), this.negYAxis.copy(this.yAxis).negate(), this.negZAxis.copy(this.zAxis).negate(), this.scaleGroup.scale.setScalar(1), s2 != null && (s2.getWorldScale(Ns), this.scaleGroup.scale.divide(Ns)), this.scaleGroup.scale.multiplyScalar(Bi(this, e, this.fixed ?? true, this.size ?? 1));
  }
  bind(e) {
    const i = qa(this, this.context), s2 = this.translationX.bind(16711680, 16776960, e), r2 = this.translationY.bind(65280, 16776960, e), o2 = this.translationZ.bind(255, 16776960, e), a = this.translationNegX.bind(16711680, 16776960, e), l2 = this.translationNegY.bind(65280, 16776960, e), c = this.translationNegZ.bind(255, 16776960, e), h = this.translationXY.bind(255, 16776960, e), u = this.translationYZ.bind(16711680, 16776960, e), p = this.translationXZ.bind(65280, 16776960, e), y = this.free.bind(e);
    return () => {
      i(), s2 == null || s2(), r2 == null || r2(), o2 == null || o2(), a == null || a(), l2 == null || l2(), c == null || c(), h == null || h(), u == null || u(), p == null || p(), y == null || y();
    };
  }
};
var tl = new Euler(0, 0, -Math.PI / 2);
var el = new Euler(0, 0, Math.PI / 2);
var Ue = class extends Ut {
  constructor(e, i, s2 = "", r2 = false, o2 = true) {
    super(e, i, s2, () => ({
      scale: this.options,
      rotate: false,
      translate: "as-scale",
      multitouch: false
    }));
    f(this, "invert");
    f(this, "showHandleLine");
    this.invert = r2, this.showHandleLine = o2;
  }
  bind(e, i, s2) {
    const { options: r2, disabled: o2 } = Dt(this.axis, s2);
    if (r2 === false)
      return;
    this.options = r2;
    const a = this.invert ? el : tl, l2 = new Group();
    l2.position.x = this.invert ? -0.5 : 0.5, l2.rotation.copy(a), this.add(l2);
    const c = new MeshBasicMaterial(at), h = bt(this.context, c, this.tag, {
      color: e,
      hoverColor: i,
      disabled: o2
    }), u = new Mesh(new BoxGeometry(0.08, 0.08, 0.08), c);
    u.renderOrder = 1 / 0, u.rotation.copy(a), l2.add(u);
    let p, y, T;
    if (this.showHandleLine) {
      T = new Group(), T.rotation.copy(a), this.add(T);
      const E = new MeshBasicMaterial(at);
      p = bt(this.context, E, this.tag, {
        color: e,
        hoverColor: i,
        disabled: o2
      }), y = new Mesh(new CylinderGeometry(75e-4, 75e-4, 0.5, 3), E), y.renderOrder = 1 / 0, y.position.y = 0.25, T.add(y);
    }
    const b = new Group();
    b.visible = false, b.rotation.copy(a), b.position.x = this.invert ? -0.3 : 0.3, this.add(b);
    const d2 = new Mesh(new CylinderGeometry(0.2, 0, 0.5, 4));
    d2.pointerEventsOrder = 1 / 0, d2.position.y = 0.04, b.add(d2);
    const v = o2 ? void 0 : this.context.registerHandle(this.store, d2, this.tag);
    return () => {
      c.dispose(), d2.geometry.dispose(), u.geometry.dispose(), y == null || y.geometry.dispose(), v == null || v(), h == null || h(), p == null || p(), T != null && this.remove(T), this.remove(b), this.remove(l2);
    };
  }
};
var _n = class extends Ut {
  constructor(t2, e, i = "") {
    super(t2, e, i, () => ({
      translate: "as-scale",
      scale: this.options,
      rotate: false,
      multitouch: false
    }));
  }
  bind(t2, e, i) {
    const { options: s2, disabled: r2 } = Dt(this.axis, i);
    if (s2 === false)
      return;
    this.options = s2;
    const o2 = new MeshBasicMaterial(at), a = bt(this.context, o2, this.tag, {
      opacity: 0.5,
      hoverOpacity: 1,
      color: t2,
      hoverColor: e,
      disabled: r2
    }), l2 = new Mesh(new BoxGeometry(0.2, 0.2, 0.01), o2);
    l2.renderOrder = 1 / 0, l2.pointerEventsOrder = 1 / 0, l2.position.set(0.15, 0.15, 0);
    const c = r2 ? void 0 : this.context.registerHandle(this.store, l2, this.tag);
    return this.add(l2), () => {
      o2.dispose(), l2.geometry.dispose(), c == null || c(), a == null || a(), this.remove(l2);
    };
  }
};
var il = new Euler(0, 0, -Math.PI / 2);
var nl = new Euler(0, 0, Math.PI / 2);
var De = class extends Ut {
  constructor(e, i = "", s2, r2 = false) {
    super(e, "xyz", i, () => ({
      scale: { uniform: true, ...this.options },
      rotate: false,
      translate: "as-scale",
      multitouch: false
    }));
    f(this, "actualAxis");
    f(this, "invert");
    this.actualAxis = s2, this.invert = r2;
  }
  bind(e, i, s2) {
    const { options: r2, disabled: o2 } = Dt(this.actualAxis, s2);
    if (r2 === false)
      return;
    this.options = r2;
    const a = this.invert ? nl : il, l2 = new Group();
    l2.position.x = this.invert ? -0.7 : 0.7, l2.rotation.copy(a), this.add(l2);
    const c = new MeshBasicMaterial(at), h = bt(this.context, c, this.tag, {
      color: e,
      hoverColor: i,
      opacity: 0.5,
      hoverOpacity: 1,
      disabled: o2
    }), u = new Mesh(new BoxGeometry(0.08, 0.08, 0.08), c);
    u.renderOrder = 1 / 0, u.rotation.copy(a), l2.add(u);
    const p = new Mesh(new BoxGeometry(0.15, 0.15, 0.15), c);
    p.visible = false, p.pointerEventsOrder = 1 / 0, p.rotation.copy(a), l2.add(p);
    const y = o2 ? void 0 : this.context.registerHandle(this.store, p, this.tag);
    return () => {
      c.dispose(), u.geometry.dispose(), y == null || y(), h == null || h(), this.remove(l2);
    };
  }
};
var js = new Vector3();
var sl = class extends Group {
  constructor(e, i, s2) {
    super();
    f(this, "context");
    f(this, "size");
    f(this, "fixed");
    f(this, "scaleX");
    f(this, "scaleY");
    f(this, "scaleZ");
    f(this, "scaleNegX");
    f(this, "scaleNegY");
    f(this, "scaleNegZ");
    f(this, "translationX");
    f(this, "translationY");
    f(this, "translationZ");
    f(this, "translationNegX");
    f(this, "translationNegY");
    f(this, "translationNegZ");
    f(this, "translationXY");
    f(this, "translationYZ");
    f(this, "translationXZ");
    this.context = e, this.size = i, this.fixed = s2, this.scaleX = new De(this.context, void 0, "x"), this.add(this.scaleX), this.scaleY = new De(this.context, void 0, "y"), this.scaleY.rotation.z = Math.PI / 2, this.add(this.scaleY), this.scaleZ = new De(this.context, void 0, "z"), this.scaleZ.rotation.y = -Math.PI / 2, this.add(this.scaleZ), this.scaleNegX = new De(this.context, void 0, "x", true), this.add(this.scaleNegX), this.scaleNegY = new De(this.context, void 0, "y", true), this.scaleNegY.rotation.z = Math.PI / 2, this.add(this.scaleNegY), this.scaleNegZ = new De(this.context, void 0, "z", true), this.scaleNegZ.rotation.y = -Math.PI / 2, this.add(this.scaleNegZ), this.translationX = new Ue(this.context, "x"), this.add(this.translationX), this.translationY = new Ue(this.context, "y"), this.translationY.rotation.z = Math.PI / 2, this.add(this.translationY), this.translationZ = new Ue(this.context, "z"), this.translationZ.rotation.y = -Math.PI / 2, this.add(this.translationZ), this.translationNegX = new Ue(this.context, "x", void 0, true, false), this.add(this.translationNegX), this.translationNegY = new Ue(this.context, "y", void 0, true, false), this.translationNegY.rotation.z = Math.PI / 2, this.add(this.translationNegY), this.translationNegZ = new Ue(this.context, "z", void 0, true, false), this.translationNegZ.rotation.y = -Math.PI / 2, this.add(this.translationNegZ), this.translationXY = new _n(this.context, "xy"), this.add(this.translationXY), this.translationXZ = new _n(this.context, "xz"), this.translationXZ.rotation.x = Math.PI / 2, this.add(this.translationXZ), this.translationYZ = new _n(this.context, "yz"), this.translationYZ.rotation.y = -Math.PI / 2, this.add(this.translationYZ);
  }
  update(e) {
    this.updateWorldMatrix(true, false), this.scale.setScalar(1);
    const i = this.context.getTarget();
    i != null && (i.getWorldScale(js), this.scale.divide(js)), this.scale.multiplyScalar(Bi(this, e, this.fixed ?? true, this.size ?? 1));
  }
  bind(e) {
    const i = this.scaleX.bind(16777215, 16776960, e), s2 = this.scaleY.bind(16777215, 16776960, e), r2 = this.scaleZ.bind(16777215, 16776960, e), o2 = this.scaleNegX.bind(16777215, 16776960, e), a = this.scaleNegY.bind(16777215, 16776960, e), l2 = this.scaleNegZ.bind(16777215, 16776960, e), c = this.translationX.bind(16711680, 16776960, e), h = this.translationY.bind(65280, 16776960, e), u = this.translationZ.bind(255, 16776960, e), p = this.translationNegX.bind(16711680, 16776960, e), y = this.translationNegY.bind(65280, 16776960, e), T = this.translationNegZ.bind(255, 16776960, e), b = this.translationXY.bind(255, 16776960, e), d2 = this.translationYZ.bind(16711680, 16776960, e), v = this.translationXZ.bind(65280, 16776960, e);
    return () => {
      c == null || c(), h == null || h(), u == null || u(), p == null || p(), y == null || y(), T == null || T(), b == null || b(), d2 == null || d2(), v == null || v(), i == null || i(), s2 == null || s2(), r2 == null || r2(), o2 == null || o2(), a == null || a(), l2 == null || l2();
    };
  }
};
var Ws = {
  x: {
    vector1: new Vector3(0, 0, -1),
    vector2: new Vector3(0, -1, 0),
    rotationOffset: new Quaternion(),
    axis: [1, 0, 0]
  },
  y: {
    vector1: new Vector3(0, 0, -1),
    vector2: new Vector3(-1, 0, -1),
    rotationOffset: new Quaternion().setFromEuler(new Euler(0, 0, Math.PI / 2)),
    axis: [0, 1, 0]
  },
  z: {
    vector1: new Vector3(-1, 0, 0),
    vector2: new Vector3(0, -1, 0),
    rotationOffset: new Quaternion().setFromEuler(new Euler(0, Math.PI / 2, 0)),
    axis: [0, 0, 1]
  }
};
var yn = new Vector3();
var ai2 = new Vector3();
var Ai = new Vector3();
var pe = new Vector3();
var Rt = new Quaternion();
var vn = class extends Ut {
  constructor(e, i, s2 = "") {
    super(e, i, s2, () => ({
      scale: false,
      translate: "as-rotate",
      rotate: [this.direction],
      multitouch: false
    }));
    f(this, "direction", new Vector3(1, 0, 0));
  }
  update(e) {
    const { rotationOffset: i, vector1: s2, vector2: r2 } = Ws[this.axis];
    e.getWorldPosition(yn), this.getWorldPosition(ai2).sub(yn), Ai.copy(s2), pe.copy(r2);
    const o2 = this.context.getTarget(), a = this.context.getSpace();
    a === "local" && o2 != null && (o2.getWorldQuaternion(Rt), Ai.applyQuaternion(Rt), pe.applyQuaternion(Rt)), pe.crossVectors(Ai, pe);
    const l2 = ai2.dot(pe);
    pe.multiplyScalar(l2), ai2.sub(pe), this.quaternion.setFromUnitVectors(Ai, ai2.normalize()), a === "local" && o2 != null && (o2.getWorldQuaternion(Rt), this.quaternion.multiply(Rt)), this.quaternion.multiply(i), (o2 == null ? void 0 : o2.parent) != null ? (o2.parent.matrixWorld.decompose(yn, Rt, ai2), Rt.invert(), this.quaternion.premultiply(Rt)) : Rt.identity(), this.store.getState() == null && (this.direction.fromArray(Ws[this.axis].axis), this.direction.applyQuaternion(a === "local" && o2 != null ? o2 == null ? void 0 : o2.quaternion : Rt)), o2 != null && this.quaternion.premultiply(Rt.copy(o2.quaternion).invert());
  }
  bind(e, i) {
    const { options: s2, disabled: r2 } = Dt(this.axis, i);
    if (s2 === false)
      return;
    this.options = s2;
    const o2 = new MeshBasicMaterial(at), a = bt(this.context, o2, this.tag, {
      color: e,
      hoverColor: 16776960,
      disabled: r2
    }), l2 = new Mesh($n(0.5, 0.5), o2);
    l2.renderOrder = 1 / 0, this.add(l2);
    const c = new Mesh(new TorusGeometry(0.5, 0.1, 4, 24));
    c.visible = false, c.pointerEventsOrder = 1 / 0, c.rotation.set(0, -Math.PI / 2, -Math.PI / 2), this.add(c);
    const h = r2 ? void 0 : this.context.registerHandle(this.store, c, this.tag);
    return () => {
      o2.dispose(), c.geometry.dispose(), l2.geometry.dispose(), h == null || h(), a == null || a(), this.remove(c), this.remove(l2);
    };
  }
};
var wn = new Vector3();
var xn = new Vector3();
var rl = new Vector3(1, 0, 0);
var li = new Quaternion();
var ol = class extends Ut {
  constructor(t2, e = "") {
    super(t2, "xyz", e, () => ({
      scale: false,
      translate: "as-rotate",
      rotate: this.options,
      multitouch: false
    }));
  }
  update(t2) {
    t2.getWorldPosition(wn), this.getWorldPosition(xn).sub(wn), this.quaternion.setFromUnitVectors(rl, xn.normalize());
    const e = this.context.getTarget();
    (e == null ? void 0 : e.parent) != null && (e.parent.matrixWorld.decompose(wn, li, xn), li.invert(), this.quaternion.premultiply(li)), e != null && (li.copy(e.quaternion).invert(), this.quaternion.premultiply(li));
  }
  bind(t2) {
    const { options: e, disabled: i } = Dt(this.axis, t2);
    if (e === false)
      return;
    this.options = e;
    const s2 = new MeshBasicMaterial(at), r2 = bt(this.context, s2, this.tag, {
      color: 16777215,
      hoverColor: 16776960,
      opacity: 0.25,
      disabled: i
    }), o2 = new Mesh($n(0.5, 1), s2);
    o2.renderOrder = 1 / 0, this.add(o2);
    const a = new Mesh(new SphereGeometry(0.25, 10, 8));
    a.visible = false, a.pointerEventsOrder = 1 / 0, this.add(a);
    const l2 = i ? void 0 : this.context.registerHandle(this.store, a, this.tag);
    return () => {
      this.pointerEvents = "none", s2.dispose(), a.geometry.dispose(), o2.geometry.dispose(), l2 == null || l2(), r2 == null || r2(), this.remove(a), this.remove(o2);
    };
  }
};
var bn = new Vector3();
var al = new Vector3();
var ll = new Vector3(1, 0, 0);
var ke = new Quaternion();
var cl = class extends Ut {
  constructor(e, i = "") {
    super(e, "e", i, () => ({
      scale: false,
      translate: "as-rotate",
      rotate: [this.direction],
      multitouch: false
    }));
    f(this, "direction", new Vector3(1, 0, 0));
  }
  update(e) {
    e.getWorldPosition(bn), this.getWorldPosition(this.direction).sub(bn).normalize(), this.quaternion.setFromUnitVectors(ll, this.direction);
    const i = this.context.getTarget();
    (i == null ? void 0 : i.parent) != null && (i.parent.matrixWorld.decompose(bn, ke, al), ke.invert(), this.quaternion.premultiply(ke), this.direction.applyQuaternion(ke)), i != null && (ke.copy(i.quaternion).invert(), this.quaternion.premultiply(ke)), this.direction.negate();
  }
  bind(e) {
    const { options: i, disabled: s2 } = Dt(this.axis, e);
    if (i === false)
      return;
    this.options = i;
    const r2 = new MeshBasicMaterial(at), o2 = bt(this.context, r2, this.tag, {
      color: 16776960,
      hoverColor: 16776960,
      opacity: 0.5,
      disabled: s2
    }), a = new Mesh($n(0.75, 1), r2);
    a.renderOrder = 1 / 0, this.add(a);
    const l2 = new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), new MeshBasicMaterial({ color: "white" }));
    l2.visible = false, l2.rotation.y = Math.PI / 2, l2.pointerEventsOrder = 1 / 0, this.add(l2);
    const c = s2 ? void 0 : this.context.registerHandle(this.store, l2, this.tag);
    return () => {
      r2.dispose(), l2.geometry.dispose(), a.geometry.dispose(), c == null || c(), o2 == null || o2(), this.remove(l2), this.remove(a);
    };
  }
};
function $n(n2, t2) {
  const e = new TorusGeometry(n2, 75e-4, 3, 64, t2 * Math.PI * 2);
  return e.rotateY(Math.PI / 2), e.rotateX(Math.PI / 2), e;
}
var qs = new Vector3();
var hl = class extends Group {
  constructor(e, i, s2) {
    super();
    f(this, "context");
    f(this, "fixed");
    f(this, "size");
    f(this, "rotationX");
    f(this, "rotationY");
    f(this, "rotationZ");
    f(this, "free");
    f(this, "screen");
    this.context = e, this.fixed = i, this.size = s2, this.rotationX = new vn(this.context, "x"), this.add(this.rotationX), this.rotationY = new vn(this.context, "y"), this.add(this.rotationY), this.rotationZ = new vn(this.context, "z"), this.add(this.rotationZ), this.free = new ol(this.context), this.add(this.free), this.screen = new cl(this.context), this.add(this.screen);
  }
  update(e) {
    this.updateWorldMatrix(true, false), this.rotationX.update(e), this.rotationY.update(e), this.rotationZ.update(e), this.free.update(e), this.screen.update(e), this.scale.setScalar(1);
    const i = this.context.getTarget();
    i != null && (i.getWorldScale(qs), this.scale.divide(qs)), this.scale.multiplyScalar(Bi(this, e, this.fixed ?? true, this.size ?? 1));
  }
  bind(e) {
    const i = this.rotationX.bind(16711680, e), s2 = this.rotationY.bind(65280, e), r2 = this.rotationZ.bind(255, e), o2 = this.screen.bind(e), a = this.free.bind(e);
    return () => {
      i == null || i(), s2 == null || s2(), r2 == null || r2(), o2 == null || o2(), a == null || a();
    };
  }
};
new Euler();
new Euler(0, 0, Math.PI / 2);
new Euler(0, -Math.PI / 2, 0);
var zr = new Vector3(0, 0, 1);
var Ii = new Vector3(0, 1, 0);
function Ni(n2, t2) {
  t2.setState(n2);
}
var Fe = new Vector3();
var Bs = new Vector3();
var re = new Euler();
var $s = new Quaternion();
function Hr2(n2, t2, e, i) {
  n2.copy(zr).applyEuler(e).applyQuaternion(i).multiplyScalar(t2);
}
function Gs(n2, t2, e, i, s2, r2) {
  Fe.set(t2, e, i), Bs.set(...s2), Fe.sub(Bs), Fe.applyQuaternion(r2);
  const o2 = Fe.length();
  Fe.divideScalar(o2), $s.setFromUnitVectors(zr, Fe), re.setFromQuaternion($s, "YXZ"), n2.distance = o2, n2.pitch = re.x, n2.yaw = re.y;
}
var Wt = new Vector3();
var _i = new Quaternion();
var Mi = new Quaternion();
function Un(n2, t2, e, i, s2, r2, o2 = Object3D.DEFAULT_UP) {
  if (_i.setFromUnitVectors(Ii, o2), re.set(n2, t2, 0, "YXZ"), s2 != null) {
    Hr2(s2, e, re, _i);
    const [a, l2, c] = i;
    s2.x += a, s2.y += l2, s2.z += c;
  }
  r2 != null && r2.setFromEuler(re).premultiply(_i);
}
function Lr({ distance: n2 = 5, origin: t2 = [0, 0, 0], pitch: e = 0, yaw: i = 0 } = {}, s2 = Object3D.DEFAULT_UP) {
  return eo((r2, o2) => ({
    distance: n2,
    origin: t2,
    pitch: e,
    yaw: i,
    activeHandle: void 0,
    getCameraTransformation(a, l2) {
      const { pitch: c, distance: h, yaw: u, origin: p } = o2();
      Un(c, u, h, p, a, l2, s2);
    },
    setCameraPosition(a, l2, c, h = false) {
      const u = {};
      if (Mi.setFromUnitVectors(s2, Ii), Gs(u, a, l2, c, o2().origin, Mi), h === true) {
        const p = o2();
        re.set(p.pitch, p.yaw, 0, "YXZ"), _i.setFromUnitVectors(Ii, s2), Hr2(Wt, p.distance, re, _i), Wt.x -= a, Wt.y -= l2, Wt.z -= c, u.origin = Wt.toArray();
      }
      r2(u);
    },
    setOriginPosition(a, l2, c, h = false) {
      const u = [a, l2, c], p = {
        origin: u
      };
      if (h === false) {
        const { pitch: y, distance: T, origin: b, yaw: d2 } = o2();
        Un(y, d2, T, b, Wt, void 0, s2), Mi.setFromUnitVectors(s2, Ii), Gs(p, Wt.x, Wt.y, Wt.z, u, Mi);
      }
      r2(p);
    }
  }));
}
function Gn(n2, t2) {
  const e = (i) => {
    const s2 = t2();
    s2 != null && i.getCameraTransformation(s2.position, s2.quaternion);
  };
  return e(n2.getState()), n2.subscribe(e);
}
function Kn(n2, t2, e, i = Object3D.DEFAULT_UP) {
  let { distance: s2, yaw: r2, origin: [o2, a, l2], pitch: c } = n2.getState();
  return (h) => {
    const u = t2();
    if (u == null || u instanceof ArrayCamera)
      return;
    let p = e();
    if (p === false)
      return;
    p === true && (p = 0.01);
    const { distance: y, yaw: T, origin: [b, d2, v], pitch: E } = n2.getState();
    s2 = Pe2(s2, y, p, h);
    let S;
    for (; Math.abs(S = T - r2) > Math.PI; )
      r2 += (S > 0 ? 2 : -2) * Math.PI;
    r2 = Pe2(r2, T, p, h), c = Pe2(c, E, p, h), o2 = Pe2(o2, b, p, h), a = Pe2(a, d2, p, h), l2 = Pe2(l2, v, p, h), Un(c, r2, s2, [o2, a, l2], u.position, u.quaternion, i);
  };
}
new Vector3();
var ul = 1e10;
var dl = new SphereGeometry(ul);
var Ks = /* @__PURE__ */ new Map();
function Ir(n2) {
  let t2 = Ks.get(n2);
  return t2 == null && (t2 = new Mesh(dl), t2.isVoidObject = true, t2.parent = n2, t2.pointerEventsOrder = -1 / 0, Ks.set(n2, t2)), t2;
}
globalThis.pointerEventspointerMap ?? (globalThis.pointerEventspointerMap = /* @__PURE__ */ new Map());
Object3D.prototype.setPointerCapture = function(n2) {
  var t2;
  (t2 = Jn(n2)) == null || t2.setCapture(this);
};
Object3D.prototype.releasePointerCapture = function(n2) {
  const t2 = Jn(n2);
  t2 == null || !t2.hasCaptured(this) || t2.setCapture(void 0);
};
Object3D.prototype.hasPointerCapture = function(n2) {
  var t2;
  return ((t2 = Jn(n2)) == null ? void 0 : t2.hasCaptured(this)) ?? false;
};
function Jn(n2) {
  var t2;
  return (t2 = globalThis.pointerEventspointerMap) == null ? void 0 : t2.get(n2);
}
new Triangle();
new Triangle();
new Vector2();
new Vector2();
new Vector2();
new Vector3();
new Matrix4();
new Vector3();
new Matrix4();
new Line3();
new Vector3();
new Plane();
new Ray();
new Vector2();
new Vector3(0, 0, 0), new Vector3(0, 0, 1);
new Matrix4();
new Vector3();
new Vector3(0, 0, -1);
new Plane();
new Vector2();
new Vector3();
new Vector3();
new Vector2();
new Matrix4();
new Vector3();
new Quaternion();
new Plane();
new Sphere();
new Vector3();
new Vector3();
new Vector3();
new Vector3(1e-4, 1e-4, 1e-4);
new Matrix4();
var ts = class {
  constructor(t2, e) {
    f(this, "apply");
    f(this, "getInitial");
    f(this, "map", /* @__PURE__ */ new Map());
    f(this, "initial");
    this.apply = t2, this.getInitial = e, this.initial = e();
  }
  bind(t2) {
    const e = this.onPointerDown.bind(this), i = this.onPointerUp.bind(this), s2 = this.onPointerMove.bind(this), r2 = Ir(t2);
    return r2.addEventListener("pointermove", s2), r2.addEventListener("pointerdown", e), r2.addEventListener("pointerup", i), () => {
      r2.removeEventListener("pointermove", s2), r2.removeEventListener("pointerdown", e), r2.removeEventListener("pointerup", i);
    };
  }
  onPointerDown(t2) {
    t2.intersection.details.type == "screen-ray" && (t2.target.setPointerCapture(t2.pointerId), this.map.set(t2.pointerId, {
      initialScreenPosition: new Vector2(),
      currentScreenPosition: t2.intersection.details.screenPoint.clone(),
      initialEvent: t2,
      latestEvent: t2
    }), this.save());
  }
  onPointerUp(t2) {
    this.map.delete(t2.pointerId) && this.save();
  }
  onPointerMove(t2) {
    if (t2.intersection.details.type != "screen-ray")
      return;
    const e = this.map.get(t2.pointerId);
    e != null && (e.latestEvent = t2, e.currentScreenPosition.copy(t2.intersection.details.screenPoint));
  }
  save() {
    for (const t2 of this.map.values())
      t2.initialScreenPosition.copy(t2.currentScreenPosition);
    this.initial = this.getInitial();
  }
  update() {
    this.map.size !== 0 && this.apply(this.initial, this.map);
  }
};
function Xi(n2, t2, e) {
  n2.set(0, 0);
  let i = 0;
  for (const s2 of t2.values())
    n2.add(s2[e]), i++;
  i !== 0 && n2.divideScalar(i);
}
var ci = new Vector2();
var Ye = new Quaternion();
var ne = new Vector3();
var En = new Vector3();
var Tn = new Vector3();
function Ur(n2, t2, e, i, s2, r2) {
  i.set(0, 0, 0);
  const o2 = t2 instanceof PerspectiveCamera ? n2.distance * 2 * Math.tan(t2.fov / 2 * Math.PI / 180) : (t2.top - t2.bottom) / t2.zoom;
  ci.copy(e).multiplyScalar(-0.5 * s2 * o2), n2.getCameraTransformation(void 0, Ye);
  const a = t2 instanceof PerspectiveCamera ? t2.aspect : (t2.right - t2.left) / (t2.top - t2.bottom);
  r2 === "screen" ? (ne.set(1, 0, 0).applyQuaternion(Ye).multiplyScalar(ci.x * a), i.add(ne), ne.set(0, 1, 0).applyQuaternion(Ye).multiplyScalar(ci.y), i.add(ne)) : (En.set(0, 0, -1).applyQuaternion(Ye), Tn.set(0, 1, 0).applyQuaternion(Ye), ne.copy(Math.abs(En.y) < Math.abs(Tn.y) ? En : Tn).setComponent(1, 0).normalize(), i.addScaledVector(ne, ci.y), ne.set(1, 0, 0).applyQuaternion(Ye).setComponent(1, 0).normalize().multiplyScalar(ci.x * a), i.add(ne));
}
var On = new Vector2();
var Js = new Vector2();
var hi = new Vector3();
var Dr = class extends ts {
  constructor(e, i, s2, r2, o2, a, l2) {
    super((c, h) => {
      if (!this.filter(h))
        return;
      Xi(On, h, "currentScreenPosition"), Xi(Js, h, "initialScreenPosition"), On.sub(Js), Ur(i.getState(), s2(), On, hi, this.speed ?? 1, this.space ?? "screen");
      const [u, p, y] = c;
      hi.x += u, hi.y += p, hi.z += y, (this.customApply ?? Ni)({ origin: hi.toArray() }, i);
    }, () => i.getState().origin);
    f(this, "canvas");
    f(this, "filter");
    f(this, "customApply");
    f(this, "speed");
    f(this, "space");
    this.canvas = e, this.filter = r2, this.customApply = o2, this.speed = a, this.space = l2;
  }
  bind(e) {
    const i = (r2) => r2.preventDefault();
    this.canvas.addEventListener("contextmenu", i);
    const s2 = super.bind(e);
    return () => {
      s2(), this.canvas.removeEventListener("contextmenu", i);
    };
  }
};
var ui = new Vector3();
var tr = new Vector2();
var kr = class extends ts {
  constructor(e, i, s2, r2, o2, a) {
    super(({ distance: l2, origin: c }, h) => {
      if (h.size < 2 || this.filter != null && !this.filter(h))
        return;
      const [u, p] = h.values(), y = u.initialScreenPosition.distanceTo(p.initialScreenPosition), b = u.currentScreenPosition.distanceTo(p.currentScreenPosition) / y, d2 = {
        distance: l2 / b
      };
      (this.zoomToPointer ?? false) && (tr.copy(u.currentScreenPosition).add(p.currentScreenPosition).multiplyScalar(0.5), d2.origin = ir(tr, e.getState(), c, i(), b)), (this.customApply ?? Ni)(d2, e);
    }, () => ({ distance: e.getState().distance, origin: e.getState().origin }));
    f(this, "store");
    f(this, "getCamera");
    f(this, "filter");
    f(this, "customApply");
    f(this, "speed");
    f(this, "zoomToPointer");
    this.store = e, this.getCamera = i, this.filter = s2, this.customApply = r2, this.speed = o2, this.zoomToPointer = a;
  }
  onWheel(e) {
    const i = Math.pow(0.95, (this.speed ?? 1) * e.deltaY * 0.01), s2 = {
      distance: this.store.getState().distance / i
    };
    if (e.intersection.details.type === "screen-ray" && (this.zoomToPointer ?? false)) {
      const r2 = this.store.getState();
      s2.origin = ir(e.intersection.details.screenPoint, r2, r2.origin, this.getCamera(), i);
    }
    (this.customApply ?? Ni)(s2, this.store);
  }
  bind(e) {
    const i = Ir(e), s2 = this.onWheel.bind(this);
    i.addEventListener("wheel", s2);
    const r2 = super.bind(e);
    return () => {
      r2(), i.removeEventListener("wheel", s2);
    };
  }
};
var er = new Vector2();
function ir(n2, t2, e, i, s2) {
  er.copy(n2).multiplyScalar(-(s2 - 1) / s2), Ur(t2, i, er, ui, 1, "screen");
  const [r2, o2, a] = e;
  return ui.x += r2, ui.y += o2, ui.z += a, ui.toArray();
}
var Ri = new Vector2();
var nr = new Vector2();
var Fr = class extends ts {
  constructor(e, i, s2, r2, o2) {
    super(([a, l2], c) => {
      if (!this.filter(c))
        return;
      Xi(Ri, c, "currentScreenPosition"), Xi(nr, c, "initialScreenPosition"), Ri.sub(nr).multiplyScalar(-Math.PI * (this.speed ?? 1));
      const h = i(), u = h instanceof PerspectiveCamera ? h.aspect : (h.right - h.left) / (h.top - h.bottom);
      (this.customApply ?? Ni)({
        pitch: a - Ri.y,
        yaw: l2 + Ri.x * u
      }, e);
    }, () => [e.getState().pitch, e.getState().yaw]);
    f(this, "filter");
    f(this, "customApply");
    f(this, "speed");
    this.filter = s2, this.customApply = r2, this.speed = o2;
  }
};
function Ui(n2, t2) {
  n2.pitch != null && (n2.pitch = Wn(n2.pitch, -Math.PI / 2, Math.PI / 2)), t2.setState(n2);
}
var fl = new Vector3();
var pl = class {
  constructor(t2, e, i) {
    f(this, "rotate");
    f(this, "pan");
    f(this, "zoom");
    f(this, "store");
    f(this, "getCamera");
    f(this, "updateDamping");
    f(this, "damping", false);
    if (i == null) {
      i = Lr();
      const s2 = typeof e == "function" ? e() : e;
      i.getState().setCameraPosition(...s2.getWorldPosition(fl).toArray());
    }
    this.store = i, this.getCamera = typeof e == "function" ? e : () => e, this.updateDamping = Kn(i, this.getCamera, () => this.damping), this.rotate = new Fr(i, this.getCamera, Gi, Ui), this.pan = new Dr(t2, i, this.getCamera, $i, Ui), this.zoom = new kr(i, this.getCamera, void 0, Ui);
  }
  getStore() {
    return this.store;
  }
  update(t2) {
    this.rotate.update(), this.pan.update(), this.zoom.update(), this.updateDamping(t2);
  }
  bind(t2, e = false) {
    const i = this.rotate.bind(t2), s2 = this.pan.bind(t2), r2 = this.zoom.bind(t2);
    let o2;
    return e === false && (o2 = Gn(this.store, this.getCamera)), this.damping = e, () => {
      i(), s2(), r2(), o2 == null || o2();
    };
  }
};
var ml = new Vector3();
function Di(n2, t2) {
  n2.pitch != null && (n2.pitch = Wn(n2.pitch, 0, Math.PI / 2)), t2.setState(n2);
}
var gl = class {
  constructor(t2, e, i) {
    f(this, "rotate");
    f(this, "pan");
    f(this, "zoom");
    f(this, "store");
    f(this, "getCamera");
    f(this, "updateDamping");
    f(this, "damping", false);
    if (i == null) {
      i = Lr();
      const s2 = typeof e == "function" ? e() : e;
      i.getState().setCameraPosition(...s2.getWorldPosition(ml).toArray());
    }
    this.store = i, this.getCamera = typeof e == "function" ? e : () => e, this.updateDamping = Kn(i, this.getCamera, () => this.damping), this.rotate = new Fr(i, this.getCamera, $i, Di), this.pan = new Dr(t2, i, this.getCamera, Gi, Di), this.zoom = new kr(i, this.getCamera, void 0, Di);
  }
  getStore() {
    return this.store;
  }
  update(t2) {
    this.rotate.update(), this.pan.update(), this.zoom.update(), this.updateDamping(t2);
  }
  bind(t2, e = false) {
    const i = this.rotate.bind(t2), s2 = this.pan.bind(t2), r2 = this.zoom.bind(t2);
    let o2;
    return e === false && (o2 = Gn(this.store, this.getCamera)), this.damping = e, () => {
      i(), s2(), r2(), o2 == null || o2();
    };
  }
};
function $i(n2) {
  if (n2.size != 1)
    return n2.size === 2;
  const [t2] = n2.values();
  return t2.initialEvent.button === 2;
}
function Gi(n2) {
  if (n2.size != 1)
    return false;
  const [t2] = n2.values();
  return t2.initialEvent.button === 0;
}
function _l(n2, t2 = {}, e) {
  const i = (0, import_react.useRef)(t2);
  i.current = t2;
  const s2 = (0, import_react.useRef)(e);
  s2.current = e;
  const r2 = (0, import_react.useMemo)(() => new Sr(n2, () => {
    var a;
    return { ...(a = s2.current) == null ? void 0 : a.call(s2), ...i.current };
  }), [n2]);
  useFrame((a) => r2.update(a.clock.getElapsedTime()), -1);
  const o2 = t2.handle ?? n2;
  return (0, import_react.useEffect)(() => {
    if (t2.bind === false)
      return;
    const a = o2.current;
    if (a != null)
      return r2.bind(a);
  }, [r2, o2, t2.bind]), r2;
}
var Dn = (0, import_react.createContext)(void 0);
(0, import_react.forwardRef)(({ targetRef: n2, children: t2 }, e) => {
  const i = (0, import_react.useRef)(null);
  return (0, import_react.useImperativeHandle)(e, () => (n2 ?? i).current, [n2]), n2 != null ? (0, import_jsx_runtime.jsx)(Dn.Provider, { value: n2, children: t2 }) : (0, import_jsx_runtime.jsx)(Dn.Provider, { value: i, children: (0, import_jsx_runtime.jsx)("group", { ref: i, children: t2 }) });
});
(0, import_react.forwardRef)(({ children: n2, handleRef: t2, useTargetFromContext: e, targetRef: i, getHandleOptions: s2, ...r2 }, o2) => {
  const a = (0, import_react.useRef)(null);
  let l2 = (0, import_react.useContext)(Dn);
  if (e === true && (i = "from-context"), i === "from-context") {
    if (l2 == null)
      throw new Error(`no HandleTarget found in the context of this handle while 'targetRef="from-context"' is set. Either wrap the Handle in a <HandleTarget> or remove the 'targetRef="from-context"' property or set it to an ref.`);
    i = l2;
  }
  const h = _l(i ?? t2 ?? a, {
    handle: t2 ?? a,
    ...r2
  }, s2);
  return (0, import_react.useImperativeHandle)(o2, () => h, [h]), t2 != null ? n2 : (0, import_jsx_runtime.jsx)("group", { ref: a, children: n2 });
});
function Yr2(n2) {
  const t2 = useThree((e) => e.controls);
  return (0, import_react.useCallback)((e, i) => (t2 != null && e.first && (t2.enabled = false), t2 != null && e.last && (t2.enabled = true), (n2 ?? Bn)(e, i)), [n2, t2]);
}
function xt(n2) {
  if (n2 === false)
    return false;
  if (n2 === true || n2 === void 0 || n2 === "disabled")
    return "disabled";
  if (typeof n2 == "string") {
    const t2 = {
      x: false,
      y: false,
      z: false,
      e: false
    };
    return t2[n2] = "disabled", t2;
  }
  return {
    x: zi(n2.x),
    y: zi(n2.y),
    z: zi(n2.z),
    e: zi(n2.e)
  };
}
function zi(n2) {
  return n2 === false ? false : "disabled";
}
(0, import_react.forwardRef)(({ children: n2, scale: t2, translation: e, rotation: i, size: s2, fixed: r2, disabled: o2, hidden: a, ...l2 }, c) => (0, import_jsx_runtime.jsxs)(yl, { ...l2, ref: c, children: [(0, import_jsx_runtime.jsx)(vl, { scale: t2, translation: e, rotation: i, size: s2, fixed: r2, hidden: a, disabled: o2 }), n2] }));
var Zr = (0, import_react.createContext)(void 0);
var yl = (0, import_react.forwardRef)(({ alwaysUpdate: n2, apply: t2, stopPropagation: e, children: i, ...s2 }, r2) => {
  const o2 = (0, import_react.useRef)(null);
  (0, import_react.useImperativeHandle)(r2, () => o2.current, []);
  const a = Yr2(t2), l2 = {
    alwaysUpdate: n2,
    apply: a,
    stopPropagation: e
  }, c = (0, import_react.useRef)(l2);
  c.current = l2;
  const h = (0, import_react.useMemo)(() => new Cr(o2, () => c.current), []);
  return useFrame((u) => h.update(u.clock.getElapsedTime()), -1), (0, import_jsx_runtime.jsx)("group", { ...s2, ref: o2, children: (0, import_jsx_runtime.jsx)(Zr.Provider, { value: h, children: i }) });
});
var vl = (0, import_react.forwardRef)(({ size: n2, fixed: t2, scale: e, rotation: i, translation: s2, disabled: r2, hidden: o2 }, a) => {
  const l2 = (0, import_react.useContext)(Zr);
  if (l2 == null)
    throw new Error("PivotHandlesHandles can only be used inside PivotHandlesContext");
  const c = (0, import_react.useMemo)(() => new Wa(l2), [l2]);
  return (0, import_react.useImperativeHandle)(a, () => c, [c]), n2 !== null && (c.size = n2), t2 !== null && (c.fixed = t2), (0, import_react.useEffect)(() => o2 ? void 0 : c.scaleX.bind(16719968, r2 ? xt(e) : e), [r2, e, c, o2]), (0, import_react.useEffect)(() => o2 ? void 0 : c.scaleY.bind(2154368, r2 ? xt(e) : e), [r2, e, c, o2]), (0, import_react.useEffect)(() => o2 ? void 0 : c.scaleZ.bind(2130175, r2 ? xt(e) : e), [r2, e, c, o2]), (0, import_react.useEffect)(() => o2 ? void 0 : c.rotationX.bind(16719968, r2 ? xt(i) : i), [r2, i, c, o2]), (0, import_react.useEffect)(() => o2 ? void 0 : c.rotationY.bind(2154368, r2 ? xt(i) : i), [r2, i, c, o2]), (0, import_react.useEffect)(() => o2 ? void 0 : c.rotationZ.bind(2130175, r2 ? xt(i) : i), [r2, i, c, o2]), (0, import_react.useEffect)(() => o2 ? void 0 : c.translationX.bind(16719968, 16777024, r2 ? xt(s2) : s2), [r2, s2, c, o2]), (0, import_react.useEffect)(() => o2 ? void 0 : c.translationY.bind(2154368, 16777024, r2 ? xt(s2) : s2), [r2, s2, c, o2]), (0, import_react.useEffect)(() => o2 ? void 0 : c.translationZ.bind(2130175, 16777024, r2 ? xt(s2) : s2), [r2, s2, c, o2]), (0, import_react.useEffect)(() => o2 ? void 0 : c.translationXY.bind(16719968, 16777024, r2 ? xt(s2) : s2), [r2, s2, c, o2]), (0, import_react.useEffect)(() => o2 ? void 0 : c.translationYZ.bind(2130175, 16777024, r2 ? xt(s2) : s2), [r2, s2, c, o2]), (0, import_react.useEffect)(() => o2 ? void 0 : c.translationXZ.bind(2154368, 16777024, r2 ? xt(s2) : s2), [r2, s2, c, o2]), useFrame((h) => c.update(h.camera)), (0, import_jsx_runtime.jsx)("primitive", { object: c });
});
var wl = new Euler();
var xl = new Euler(0, 0, Math.PI / 2);
var bl = new Euler(0, -Math.PI / 2, 0);
var El = (0, import_react.forwardRef)(({ children: n2, mode: t2, size: e, fixed: i, disabled: s2, hidden: r2, x: o2, y: a, z: l2, e: c, ...h }, u) => (0, import_jsx_runtime.jsxs)(Tl, { ...h, ref: u, children: [(0, import_jsx_runtime.jsx)(Ol, { hidden: r2, disabled: s2, mode: t2, x: o2, y: a, z: l2, e: c, size: e, fixed: i }), (0, import_jsx_runtime.jsx)(Pn, { tag: "x", rotationOffset: wl }), (0, import_jsx_runtime.jsx)(Pn, { tag: "y", rotationOffset: xl }), (0, import_jsx_runtime.jsx)(Pn, { tag: "z", rotationOffset: bl }), n2] }));
var Pn = (0, import_react.forwardRef)(({ tag: n2, rotationOffset: t2 }, e) => {
  const i = (0, import_react.useContext)(es);
  if (i == null)
    throw new Error("HandlesAxisHighlight can only be used inside TransformHandlesContext");
  const s2 = (0, import_react.useMemo)(() => new Va(i, t2), [i, t2]);
  return (0, import_react.useImperativeHandle)(e, () => s2, [s2]), (0, import_react.useEffect)(() => s2.bind(n2), [s2, n2]), useFrame(() => s2.update()), (0, import_jsx_runtime.jsx)("primitive", { object: s2 });
});
var es = (0, import_react.createContext)(void 0);
var Tl = (0, import_react.forwardRef)(({ alwaysUpdate: n2, apply: t2, stopPropagation: e, children: i, context: s2, space: r2, ...o2 }, a) => {
  const l2 = (0, import_react.useRef)(null), c = Yr2(t2);
  (0, import_react.useImperativeHandle)(a, () => l2.current, []);
  const h = {
    alwaysUpdate: n2,
    apply: c,
    stopPropagation: e
  }, u = (0, import_react.useRef)(h);
  u.current = h;
  const p = (0, import_react.useMemo)(() => s2 ?? new Cr(l2, () => u.current), [s2]);
  return r2 !== null && (p.space = r2), useFrame((y) => p.update(y.clock.getElapsedTime()), -1), (0, import_jsx_runtime.jsx)("group", { ...o2, ref: l2, children: (0, import_jsx_runtime.jsx)(es.Provider, { value: p, children: i }) });
});
var Ol = (0, import_react.forwardRef)(({ mode: n2 = "translate", x: t2, y: e, z: i, e: s2, size: r2, fixed: o2, disabled: a, hidden: l2 }, c) => {
  const h = (0, import_react.useContext)(es);
  if (h == null)
    throw new Error("TransformHandlesHandles can only be used inside TransformHandlesContext");
  const u = (0, import_react.useMemo)(() => {
    switch (n2) {
      case "rotate":
        return new hl(h);
      case "scale":
        return new sl(h);
      case "translate":
        return new Ja(h);
    }
  }, [h, n2]);
  return r2 !== null && (u.size = r2), o2 !== null && (u.fixed = o2), (0, import_react.useImperativeHandle)(c, () => u, [u]), useFrame((p) => u.update(p.camera)), (0, import_react.useEffect)(() => l2 ? void 0 : u.bind(a ? xt({ x: t2, y: e, z: i, e: s2 }) : { x: t2, y: e, z: i, e: s2 }), [u, l2, a, t2, e, i, s2]), (0, import_jsx_runtime.jsx)("primitive", { object: u });
});
function Nr(n2, t2, e, i, { apply: s2, rotate: r2, zoom: o2, pan: a, store: l2, camera: c, damping: h, disabled: u }) {
  const p = useStore(), y = (0, import_react.useRef)(c);
  y.current = c;
  const T = (0, import_react.useCallback)(() => y.current ?? p.getState().camera, [p]), b = useThree((x) => x.gl.domElement), d2 = (0, import_react.useMemo)(() => new n2(b, T, l2), [b, n2, T, l2]);
  Pl(d2.getStore(), !u, h, c), useFrame((x, O) => d2.update(O * 1e3));
  const v = useThree((x) => x.scene), E = !u && (typeof a == "boolean" ? a : true);
  (0, import_react.useEffect)(() => E ? d2.pan.bind(v) : void 0, [d2, E, v]), d2.pan.customApply = s2, d2.pan.speed = typeof a == "boolean" || a == null ? void 0 : a.speed, d2.pan.filter = (typeof a == "boolean" || a == null ? void 0 : a.filter) ?? e;
  const S = !u && (typeof r2 == "boolean" ? r2 : true);
  (0, import_react.useEffect)(() => S ? d2.rotate.bind(v) : void 0, [d2, S, v]), d2.rotate.customApply = s2 ?? i, d2.rotate.speed = typeof r2 == "boolean" || r2 == null ? void 0 : r2.speed, d2.rotate.filter = (typeof r2 == "boolean" || r2 == null ? void 0 : r2.filter) ?? t2;
  const M = !u && (typeof o2 == "boolean" ? o2 : true);
  (0, import_react.useEffect)(() => M ? d2.zoom.bind(v) : void 0, [d2, M, v]), d2.zoom.customApply = s2, d2.zoom.speed = typeof o2 == "boolean" || o2 == null ? void 0 : o2.speed, d2.zoom.filter = typeof o2 == "boolean" || o2 == null ? void 0 : o2.filter;
}
function Pl(n2, t2 = false, e = false, i) {
  const s2 = useStore(), r2 = (0, import_react.useRef)(i);
  r2.current = i;
  const o2 = (0, import_react.useCallback)(() => r2.current ?? s2.getState().camera, [s2]), a = e !== false;
  (0, import_react.useEffect)(() => !t2 && !a ? Gn(n2, o2) : void 0, [a, t2, o2, n2]);
  const l2 = (0, import_react.useRef)(e);
  l2.current = e;
  const c = (0, import_react.useMemo)(() => Kn(n2, o2, () => l2.current), [n2, o2]);
  useFrame((h, u) => c(u * 1e3));
}
Nr.bind(null, gl, $i, Gi, Di);
Nr.bind(null, pl, Gi, $i, Ui);
function sr(n2, t2) {
  if (t2 === "translate")
    return n2.current.position.toArray().map(We);
  if (t2 === "rotate") {
    const e = n2.current.rotation.toArray();
    return e.pop(), e;
  } else {
    if (t2 === "scale")
      return n2.current.scale.toArray().map(We);
    throw new Error("invariant");
  }
}
function Sl({
  enabled: n2,
  mode: t2,
  object: e,
  onChange: i,
  onConfirm: s2,
  onTransformEnd: r2,
  onTransformStart: o2,
  space: a
}) {
  const l2 = (0, import_react.useRef)(null), c = (0, import_react.useRef)(void 0), h = V((y) => y.lock), u = V((y) => y.release), p = Oe((y) => {
    y.first && (window.clearTimeout(c.current), h(), o2 == null || o2()), i == null || i({
      mode: t2,
      value: sr(y, t2)
    }), y.last && (s2 == null || s2({
      mode: t2,
      value: sr(y, t2)
    }), r2 == null || r2(), c.current = window.setTimeout(() => {
      u();
    }, 33));
  });
  return useFrame(() => {
    l2.current && (l2.current.position.copy(e.position), l2.current.quaternion.copy(e.quaternion), l2.current.scale.copy(e.scale));
  }), (0, import_react.useLayoutEffect)(() => {
    l2.current && (l2.current.position.copy(e.position), l2.current.quaternion.copy(e.quaternion), l2.current.scale.copy(e.scale));
  }, [e]), e.parent ? (0, import_jsx_runtime.jsx)(ii.Provider, { value: false, children: createPortal(
    (0, import_jsx_runtime.jsx)(
      El,
      {
        apply: p,
        disabled: !n2,
        mode: t2,
        ref: l2,
        size: 0.5,
        space: a,
        children: (0, import_jsx_runtime.jsx)("group", {})
      }
    ),
    /**
     * It's important that the placeholder is rendered at the same scene
     * position as the object otherwise inherited transforms from parents
     * will end up being super whacky.
     */
    e.parent
  ) }, e.id) : null;
}
var Cl = (n2, t2) => {
  const e = t2.transform === "none" ? "translate" : t2.transform;
  let i, s2;
  return n2.traverse((r2) => {
    const o2 = Gt(r2);
    o2 && (!i && o2[e] && (i = r2), !s2 && o2.translate && (s2 = r2));
  }), i || s2 || n2;
};
var Xr2 = (n2, t2) => {
  const e = [];
  return n2.traverse((i) => {
    if (!ai(i))
      return;
    const s2 = i.__triplex;
    if (s2.astPath === t2.astPath && ur("selection_ast_path") || s2.path === t2.path && s2.column === t2.column && s2.line === t2.line) {
      e.push([i, s2]);
      return;
    }
    for (const r2 of s2.parents)
      if ((r2.astPath === t2.astPath && ur("selection_ast_path") || r2.path === t2.path && r2.column === t2.column && r2.line === t2.line) && r2.originExportName !== "Canvas") {
        e.push([i, r2]);
        return;
      }
  }), e;
};
var Al = (n2, t2) => Xr2(n2, t2).map(([i, s2]) => {
  const r2 = /^[a-z]/.test(s2.name) ? i : Cl(i, t2);
  return {
    meta: s2,
    object: r2
  };
});
var Vi = new Raycaster();
var rr = new Vector2();
function Ml(n2, t2) {
  return t2.camera ? (rr.set(n2.x, n2.y), Vi.setFromCamera(rr, t2.camera), Vi.intersectObject(t2.scene).filter(
    (i) => br(i.object) && i.object.type !== "TransformControlsPlane"
  )) : [];
}
function Rl(n2, t2) {
  return Vi.set(n2.origin, n2.direction), Vi.intersectObject(t2.scene).filter((i) => br(i.object));
}
var or = `uniform sampler2D u_selectionMask;
uniform sampler2D u_hoveredMask;
uniform vec3 u_lineColor;
uniform vec2 u_viewportSize;
uniform float u_lineWeight;

varying vec2 v_uv;

float sampleMask(sampler2D mask, float lineWeight) {
  float dx = 1.0 / u_viewportSize.x * lineWeight;
  float dy = 1.0 / u_viewportSize.y * lineWeight;

  vec2 uvCenter = v_uv;
  vec2 uvTop = vec2(uvCenter.x, uvCenter.y - dy);
  vec2 uvRight = vec2(uvCenter.x + dx, uvCenter.y);
  vec2 uvTopRight = vec2(uvCenter.x + dx, uvCenter.y - dy);

  float mCenter = texture2D(mask, uvCenter).a;
  float mTop = texture2D(mask, uvTop).a;
  float mRight = texture2D(mask, uvRight).a;
  float mTopRight = texture2D(mask, uvTopRight).a;

  float dT = abs(mCenter - mTop);
  float dR = abs(mCenter - mRight);
  float dTR = abs(mCenter - mTopRight);

  float delta = 0.0;
  delta = max(delta, dT);
  delta = max(delta, dR);
  delta = max(delta, dTR);

  return delta;
}

void main() {
  float delta = sampleMask(u_selectionMask, u_lineWeight);

  if (delta > 0.0) {
    gl_FragColor = vec4(u_lineColor, 1.0);
    return;
  }

  delta = sampleMask(u_hoveredMask, u_lineWeight);

  if (delta > 0.0) {
    gl_FragColor = vec4(u_lineColor, 1.0);
    return;
  }

  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
}`;
var ar = `varying vec2 v_uv;

void main() {
  v_uv = uv;
  gl_Position = vec4(position, 0.5);
}`;
var zl = new MeshBasicMaterial({
  color: "red",
  transparent: false
});
function Hl() {
  const n2 = Fi(), t2 = Fi(), e = (0, import_react.useRef)(null), [i] = (0, import_react.useState)(() => new Vector2()), s2 = (0, import_react.useContext)(vo);
  return useFrame((r2) => {
    if (!s2)
      return;
    const { camera: o2 } = s2;
    i.set(n2.width, n2.height);
    const a = o2.layers.mask, l2 = r2.scene.background, c = r2.scene.overrideMaterial;
    r2.scene.background = null, r2.scene.overrideMaterial = zl, r2.gl.setRenderTarget(n2), o2.layers.set(o), r2.gl.render(r2.scene, o2), r2.gl.setRenderTarget(t2), o2.layers.set(r), r2.gl.render(r2.scene, o2), r2.gl.setRenderTarget(null), o2.layers.mask = a, r2.scene.background = l2, r2.scene.overrideMaterial = c;
  }), (0, import_jsx_runtime.jsxs)("mesh", { frustumCulled: false, layers: n, raycast: () => null, children: [
    (0, import_jsx_runtime.jsx)("planeGeometry", {}),
    (0, import_jsx_runtime.jsx)(
      "shaderMaterial",
      {
        depthTest: false,
        fragmentShader: or,
        ref: e,
        transparent: true,
        uniforms: {
          u_hoveredMask: { value: t2.texture },
          u_lineColor: { value: [59 / 255, 130 / 255, 246 / 255] },
          u_lineWeight: { value: 1.5 },
          u_selectionMask: { value: n2.texture },
          u_viewportSize: { value: i }
        },
        vertexShader: ar
      },
      Do(or + ar)
    )
  ] });
}
var kn = (0, import_react.memo)(({ objects: n2 }) => {
  const [t2] = (0, import_react.useState)(() => new Box3());
  return useFrame(() => {
    t2.makeEmpty();
    for (const e of n2)
      t2.expandByObject(e.object);
  }), (0, import_jsx_runtime.jsx)("box3Helper", { args: [t2, "rgb(59,130,246)"] });
});
kn.displayName = "Outline";
function Ll({
  hovered: n2,
  selections: t2
}) {
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    n2.length > 0 && (0, import_jsx_runtime.jsx)(kn, { objects: n2 }),
    t2.length > 0 && (0, import_jsx_runtime.jsx)(kn, { objects: t2 })
  ] });
}
var Sn = {
  rotate: {
    ctrl: MathUtils.degToRad(10),
    default: Math.PI / 180
  },
  scale: { ctrl: 0.1, default: 0.01 },
  translate: { ctrl: 1, default: 0.01 }
};
function Il({
  enabled: n2,
  mode: t2,
  object: e,
  onCompleteTransform: i,
  space: s2
}) {
  const r2 = (0, import_react.useRef)(null), o2 = (0, import_react.useContext)(Es), a = (0, import_react.useContext)(vo), l2 = vr({ isDisabled: !n2 }), [c, h] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    const y = (b) => {
      o2 && (o2.enabled = !b.value);
    }, T = r2.current;
    return T.addEventListener("dragging-changed", y), () => {
      T.removeEventListener("dragging-changed", y);
    };
  }, [o2]), (0, import_react.useEffect)(() => {
    const y = (T) => {
      c && T.key === "Escape" && T.stopPropagation();
    };
    return document.addEventListener("keydown", y), () => document.removeEventListener("keydown", y);
  }, [c]);
  const u = Oe(() => {
    h(true);
  }), p = Oe(() => {
    h(false), i == null || i();
  });
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    false,
    (0, import_jsx_runtime.jsx)(
      wr,
      {
        camera: (a == null ? void 0 : a.camera) || void 0,
        enabled: n2,
        mode: t2,
        object: e,
        onMouseDown: u,
        onMouseUp: p,
        ref: r2,
        rotationSnap: Ze(Sn.rotate, l2),
        scaleSnap: Ze(Sn.scale, l2),
        space: s2,
        translationSnap: Ze(Sn.translate, l2)
      }
    )
  ] });
}
var Cn = {
  rotate: {
    ctrl: MathUtils.degToRad(10),
    default: Math.PI / 180
  },
  scale: { ctrl: 0.1, default: 0.01 },
  translate: { ctrl: 1, default: 0.01 }
};
var An = {
  position: [0, 0, 0],
  rotation: [0, 0, 0],
  scale: [1, 1, 1]
};
function lr(n2, t2) {
  if (t2 === "translate")
    return n2.position.toArray().map(We);
  if (t2 === "rotate") {
    const e = n2.rotation.toArray();
    return e.pop(), e;
  } else {
    if (t2 === "scale")
      return n2.scale.toArray().map(We);
    throw new Error("invariant");
  }
}
function Ul({
  enabled: n2,
  mode: t2,
  object: e,
  onChange: i,
  onConfirm: s2,
  space: r2
}) {
  const o2 = (0, import_react.useRef)(null), a = (0, import_react.useContext)(Es), l2 = (0, import_react.useContext)(vo), c = vr({ isDisabled: !n2 }), [h, u] = (0, import_react.useState)(false), [p, y] = (0, import_react.useState)(
    () => new Object3D()
  );
  (0, import_react.useEffect)(() => {
    if (!o2.current)
      return;
    const v = (S) => {
      a && (a.enabled = !S.value);
    }, E = o2.current;
    return E.addEventListener("dragging-changed", v), () => {
      E.removeEventListener("dragging-changed", v);
    };
  }, [a]), (0, import_react.useEffect)(() => {
    const v = (E) => {
      h && E.key === "Escape" && E.stopPropagation();
    };
    return document.addEventListener("keydown", v), () => document.removeEventListener("keydown", v);
  }, [h]);
  const T = Oe(() => {
    u(true);
  }), b = Oe(() => {
    u(false), s2 == null || s2({
      mode: t2,
      value: lr(p, t2)
    });
  }), d2 = Oe(() => {
    i == null || i({
      mode: t2,
      value: lr(p, t2)
    });
  });
  return useFrame(() => {
    h || (ur("transform_controls_read_from_props") ? applyProps(p, {
      position: e.meta.props.current.position || An.position,
      rotation: e.meta.props.current.rotation || An.rotation,
      scale: e.meta.props.current.scale || An.scale
    }) : (p.position.copy(e.object.position), p.rotation.copy(e.object.rotation), p.scale.copy(e.object.scale)));
  }), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    false,
    (0, import_jsx_runtime.jsx)(
      wr,
      {
        camera: (l2 == null ? void 0 : l2.camera) || void 0,
        enabled: n2,
        mode: t2,
        object: p,
        onMouseDown: T,
        onMouseUp: b,
        onObjectChange: d2,
        ref: o2,
        rotationSnap: Ze(Cn.rotate, c),
        scaleSnap: Ze(Cn.scale, c),
        space: r2,
        translationSnap: Ze(Cn.translate, c)
      }
    ),
    e.object.parent && (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: createPortal(
      (0, import_jsx_runtime.jsx)("group", { ref: y }),
      /**
       * It's important that the placeholder is rendered at the same scene
       * position as the object otherwise inherited transforms from
       * parents will end up being super whacky.
       */
      e.object.parent
    ) }, e.object.id)
  ] });
}
function Dl({
  children: n2,
  filter: t2
}) {
  const e = (0, import_react.useContext)(ss), i = d((x) => x.setSpace), s2 = d((x) => x.setTransform), r2 = d((x) => x.transform), o2 = d((x) => x.space), a = useThree((x) => x.scene), l2 = (0, import_react.useContext)(vo), c = useThree((x) => x.gl), [h, u] = Or(
    {
      rotate: false,
      scale: false,
      translate: false
    },
    "element-transforms"
  ), [p, y, T] = Go({
    listener: (x) => {
      if ("inputSourceOrigin" in x)
        return Rl(
          { direction: x.inputSourceDirection, origin: x.inputSourceOrigin },
          { scene: a }
        ).map((k) => {
          const D = $o(k.object, t2);
          if (D)
            return {
              astPath: D.astPath,
              column: D.column,
              line: D.line,
              parentPath: t2.path,
              path: D.path,
              point: k.point
            };
        }).filter((k) => !!k);
      const O = c.domElement.getBoundingClientRect();
      if (!(x.clientX >= O.left && x.clientX <= O.left + O.width && x.clientY >= O.top && x.clientY <= O.top + O.height))
        return [];
      const Q = x.clientX - O.left, ht = x.clientY - O.top, _t = Q / O.width * 2 - 1, kt = -(ht / O.height) * 2 + 1;
      return Ml(
        { x: _t, y: kt },
        { camera: l2 == null ? void 0 : l2.camera, scene: a }
      ).map((k) => {
        const D = $o(k.object, t2);
        if (D)
          return {
            astPath: D.astPath,
            column: D.column,
            line: D.line,
            parentPath: t2.path,
            path: D.path
          };
      }).filter((k) => !!k);
    },
    onDeselect: (x) => {
      x.object.traverse(
        (O) => O.layers.disable(o)
      );
    },
    onHovered: (x) => {
      x.object.traverse(
        (O) => O.layers.enable(r)
      );
    },
    onSelect: (x) => {
      x.object.traverse(
        (O) => O.layers.enable(o)
      );
    },
    onSettled: (x) => {
      x.object.traverse(
        (O) => O.layers.disable(r)
      );
    },
    priority: 0,
    resolve: (x) => x.flatMap((O) => Al(a, {
      astPath: O.astPath,
      column: O.column,
      line: O.line,
      path: O.parentPath,
      transform: r2
    }))
  }), b = (0, import_react.useContext)(Es), d2 = p.at(0), v = p.map((x) => x.object).find((x) => x instanceof Camera);
  (0, import_react.useEffect)(() => F("extension-point-triggered", (x) => {
    if (x.scope === "scene")
      switch (x.id) {
        case "translate":
        case "scale":
        case "rotate":
        case "none": {
          s2(x.id);
          break;
        }
        case "transformlocal":
          return i("local"), { handled: true };
        case "transformworld":
          return i("world"), { handled: true };
      }
  }), [i, s2]), (0, import_react.useEffect)(() => Pe([
    F("element-focused-props", ({ props: x }) => {
      u({
        rotate: x.includes("rotation"),
        scale: x.includes("scale"),
        translate: x.includes("position")
      });
    }),
    F("request-open-component", (x) => {
      !x && !d2 || !x && d2 && d2.meta.originExportName && d2.meta.originPath && (e({
        exportName: d2.meta.originExportName,
        path: d2.meta.originPath,
        props: No(d2)
      }), N("element-blurred", void 0));
    }),
    F("request-jump-to-element", (x) => {
      const O = x ? Xr2(a, x).map((A) => A[0]) : p.map((A) => A.object);
      O.length === 0 || !b || (N("track", { actionId: "element_jumpto" }), jn(O, b));
    })
  ]), [
    b,
    d2,
    p,
    a,
    e,
    u
  ]);
  const E = Oe((x) => {
    d2 && (x.mode === "translate" ? (N("element-set-prop", {
      astPath: d2.meta.astPath,
      column: d2.meta.column,
      line: d2.meta.line,
      path: d2.meta.path,
      propName: "position",
      propValue: x.value
    }), N("track", { actionId: "element_transform_translate" })) : x.mode === "rotate" ? (N("element-set-prop", {
      astPath: d2.meta.astPath,
      column: d2.meta.column,
      line: d2.meta.line,
      path: d2.meta.path,
      propName: "rotation",
      propValue: x.value
    }), N("track", { actionId: "element_transform_rotate" })) : x.mode === "scale" && (N("element-set-prop", {
      astPath: d2.meta.astPath,
      column: d2.meta.column,
      line: d2.meta.line,
      path: d2.meta.path,
      propName: "scale",
      propValue: x.value
    }), N("track", { actionId: "element_transform_scale" })));
  }), S = Oe((x) => {
    if (!d2)
      return;
    const O = (A) => ({
      astPath: d2.meta.astPath,
      column: d2.meta.column,
      line: d2.meta.line,
      path: d2.meta.path,
      propName: A,
      propValue: x.value
    });
    x.mode === "translate" ? N("element-preview-prop", O("position")) : x.mode === "rotate" ? N("element-preview-prop", O("rotation")) : x.mode === "scale" && N("element-preview-prop", O("scale"));
  }), M = Oe(() => {
    if (d2) {
      if (r2 === "translate") {
        const x = d2.object.position.toArray();
        N("element-set-prop", {
          astPath: d2.meta.astPath,
          column: d2.meta.column,
          line: d2.meta.line,
          path: d2.meta.path,
          propName: "position",
          propValue: x.map(We)
        }), N("track", { actionId: "element_transform_translate" });
      } else if (r2 === "rotate") {
        const x = d2.object.rotation.toArray();
        x.pop(), N("element-set-prop", {
          astPath: d2.meta.astPath,
          column: d2.meta.column,
          line: d2.meta.line,
          path: d2.meta.path,
          propName: "rotation",
          propValue: x
        }), N("track", { actionId: "element_transform_rotate" });
      } else if (r2 === "scale") {
        const x = d2.object.scale.toArray();
        N("element-set-prop", {
          astPath: d2.meta.astPath,
          column: d2.meta.column,
          line: d2.meta.line,
          path: d2.meta.path,
          propName: "scale",
          propValue: x.map(We)
        }), N("track", { actionId: "element_transform_scale" });
      }
    }
  });
  return (0, import_jsx_runtime.jsxs)(ii.Provider, { value: true, children: [
    (0, import_jsx_runtime.jsx)(
      ko.Provider,
      {
        value: T.resolveSelections,
        children: n2
      }
    ),
    !!d2 && r2 !== "none" && window.triplex.env.mode === "default" && Object.values(h).some(Boolean) && ur("immutable_transform_controls") && (0, import_jsx_runtime.jsx)(
      Ul,
      {
        enabled: /^[a-z]/.test(d2.meta.name) ? true : h[r2],
        mode: r2,
        object: d2,
        onChange: S,
        onConfirm: E,
        space: o2
      }
    ),
    !!d2 && r2 !== "none" && window.triplex.env.mode === "default" && !ur("immutable_transform_controls") && (0, import_jsx_runtime.jsx)(
      Il,
      {
        enabled: /^[a-z]/.test(d2.meta.name) ? true : h[r2],
        mode: r2,
        object: d2.object,
        onCompleteTransform: M,
        space: o2
      }
    ),
    window.triplex.env.mode === "webxr" && !!d2 && r2 !== "none" && (0, import_jsx_runtime.jsx)(
      Sl,
      {
        enabled: /^[a-z]/.test(d2.meta.name) ? true : h[r2],
        mode: r2,
        object: d2.object,
        onChange: S,
        onConfirm: E,
        space: o2
      }
    ),
    window.triplex.env.mode === "default" && (l2 == null ? void 0 : l2.type) === "editor" && v && (0, import_jsx_runtime.jsx)(Ta, { camera: v }),
    window.triplex.env.mode === "default" && // Disable the selection post processing in CI tests as they don't have GPUs.
    (0, import_jsx_runtime.jsx)(Hl, {}),
    window.triplex.env.mode === "webxr" && (0, import_jsx_runtime.jsx)(Ll, { hovered: y, selections: p })
  ] });
}
function kl(n2, t2) {
  return n2 === null ? "" : n2.split(`
`)[t2 - 1];
}
function cr(n2, t2) {
  var s2;
  const e = (s2 = n2.getShaderInfoLog(t2)) == null ? void 0 : s2.trim().replaceAll(`
`, "");
  if (!e)
    return "";
  const i = /ERROR: 0:(\d+)/.exec(e);
  if (i) {
    const r2 = Number.parseInt(i[1]), o2 = kl(
      n2.getShaderSource(t2),
      r2
    );
    return `"${e}" from line "${o2}"`;
  } else
    return e;
}
function Fl() {
  const n2 = useThree((e) => e.gl), t2 = Oe(
    (e, i, s2, r2) => {
      var c;
      const o2 = cr(e, s2), a = cr(e, r2);
      let l2;
      o2 && a ? l2 = `Vertex and fragment shaders failed to compile. The vertex shader errored with ${o2} and the fragment shader errored with ${a}.` : o2 ? l2 = `A vertex shader failed to compile because of the error ${o2}.` : a ? l2 = `A fragment shader failed to compile because of the error ${a}.` : l2 = `A shader failed to compile because of the error "${(c = e.getProgramInfoLog(i)) == null ? void 0 : c.trim().replaceAll(`
`, "")}".`, N("error", {
        message: l2,
        subtitle: "",
        title: "GLSL Error"
      });
    }
  );
  return (0, import_react.useLayoutEffect)(() => {
    n2.debug.onShaderError = t2;
  }, [t2, n2.debug]), null;
}
function Yl() {
  const { meta: n2 } = Os(), t2 = n2.lighting === "default", [e, i] = (0, import_react.useState)(
    t2
  );
  return (0, import_react.useEffect)(() => F("extension-point-triggered", (s2) => {
    if (s2.scope === "scene")
      switch (s2.id) {
        case "default_lights_on":
          return i(true), { handled: true };
        case "default_lights_off":
          return i(false), { handled: true };
      }
  }), []), (0, import_react.useLayoutEffect)(() => {
    N("extension-point-triggered", {
      id: t2 ? "default_lights_off" : "default_lights_on"
    }), i(t2);
  }, [t2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    e && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
      (0, import_jsx_runtime.jsx)(
        "hemisphereLight",
        {
          color: "#87CEEB",
          groundColor: "#362907",
          intensity: 0.3
        }
      ),
      (0, import_jsx_runtime.jsx)("ambientLight", { intensity: 0.3 }),
      (0, import_jsx_runtime.jsx)("directionalLight", { intensity: 0.5, position: [2.5, 8, 5] }),
      (0, import_jsx_runtime.jsx)(
        "pointLight",
        {
          color: "#eef4aa",
          intensity: 0.5,
          position: [-10, 0, -20]
        }
      )
    ] }),
    false
  ] });
}
function Jl({ children: n2, ...t2 }) {
  var h;
  const e = ni(), { exportName: i, path: s2, providerPath: r2, providers: o2, scene: a } = Os(), l2 = po((u) => u.setMounted), c = (0, import_react.useRef)(null);
  return (0, import_react.useEffect)(() => {
    var u;
    e === "play" && ((u = c.current) == null || u.focus());
  }, [e]), (0, import_react.useLayoutEffect)(() => (l2(true), () => {
    l2(false);
  }), [l2]), (0, import_jsx_runtime.jsxs)(
    Canvas,
    {
      shadows: true,
      ...t2,
      raycaster: {
        ...t2.raycaster,
        layers: e === "play" ? ((h = t2.raycaster) == null ? void 0 : h.layers) ?? l : (
          // This forces the default r3f raycaster to be fired on a different layer (31)
          // than the default layer (0) that object3d's are set to default.
          n
        )
      },
      ref: c,
      children: [
        (0, import_jsx_runtime.jsx)(Fl, {}),
        (0, import_jsx_runtime.jsx)(ba, { children: (0, import_jsx_runtime.jsx)(
          Xr,
          {
            fallbackRender: () => (0, import_jsx_runtime.jsx)(Yr, {}),
            onError: (u) => N("error", {
              message: u.message,
              source: r2,
              stack: u.stack,
              subtitle: "The scene could not be rendered because there was an error in the provider component. Resolve the errors and try again.",
              title: "Could not render scene"
            }),
            resetKeys: [a, o2],
            children: (0, import_jsx_runtime.jsx)(
              import_react.Suspense,
              {
                fallback: (0, import_jsx_runtime.jsx)(ei.In, { children: (0, import_jsx_runtime.jsx)(
                  Hr,
                  {
                    color: "rgb(59 130 246)",
                    position: "hint",
                    variant: "stroke"
                  }
                ) }),
                children: (0, import_jsx_runtime.jsx)(
                  dt,
                  {
                    __component: o2.CanvasProvider,
                    __meta: {
                      astPath: "global/CanvasProvider",
                      column: -999,
                      exportName: "CanvasProvider",
                      line: -999,
                      name: "CanvasProvider",
                      path: r2,
                      rotate: false,
                      scale: false,
                      translate: false
                    },
                    forceInsideSceneObjectContext: true,
                    children: (0, import_jsx_runtime.jsx)(Dl, { filter: { exportName: i, path: s2 }, children: (0, import_jsx_runtime.jsxs)(
                      import_react.Suspense,
                      {
                        fallback: (0, import_jsx_runtime.jsx)(ei.In, { children: (0, import_jsx_runtime.jsx)(
                          Hr,
                          {
                            color: "rgb(59 130 246)",
                            position: "hint",
                            variant: "stroke"
                          }
                        ) }),
                        children: [
                          n2,
                          (0, import_jsx_runtime.jsx)(Ea, {}),
                          (0, import_jsx_runtime.jsx)(_a, { resetKeys: [s2, i] }),
                          (0, import_jsx_runtime.jsx)(Yl, {}),
                          window.triplex.env.mode === "default" && (0, import_jsx_runtime.jsx)(Yo, {}),
                          window.triplex.env.mode === "default" && (0, import_jsx_runtime.jsx)(ga, {})
                        ]
                      }
                    ) })
                  }
                )
              }
            )
          }
        ) })
      ]
    }
  );
}
export {
  Jl as Canvas
};
/*! Bundled license information:

@triplex/renderer/dist/canvas-BKDKP_u_.mjs:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=canvas-BKDKP_u_-O7MPXE3P.js.map
